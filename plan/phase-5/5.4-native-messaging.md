# 5.4 Native Messaging Bridge

**Objective:** Implement native messaging host to bridge browser extensions with macOS daemon.

## Overview

Native messaging allows browser extensions to communicate with native applications using stdin/stdout. Required for Chrome and Firefox extensions.

## Implementation Steps

### Step 1: Native Messaging Host Binary

Create `FocusDragonNativeHost/main.swift`:

```swift
import Foundation

class NativeMessagingHost {
    private let stdin = FileHandle.standardInput
    private let stdout = FileHandle.standardOutput
    private let stderr = FileHandle.standardError

    func start() {
        log("Native messaging host started")

        // Listen for messages
        while true {
            guard let message = readMessage() else {
                break
            }

            handleMessage(message)
        }

        log("Native messaging host stopped")
    }

    private func readMessage() -> [String: Any]? {
        // Read 4-byte message length (native endian)
        let lengthData = stdin.readData(ofLength: 4)
        guard lengthData.count == 4 else {
            return nil
        }

        // Convert to UInt32
        let length = lengthData.withUnsafeBytes { $0.load(as: UInt32.self) }

        // Read message
        let messageData = stdin.readData(ofLength: Int(length))
        guard messageData.count == Int(length) else {
            return nil
        }

        // Parse JSON
        return try? JSONSerialization.jsonObject(with: messageData) as? [String: Any]
    }

    private func sendMessage(_ message: [String: Any]) {
        guard let data = try? JSONSerialization.data(withJSONObject: message) else {
            return
        }

        // Send length (4 bytes, native endian)
        var length = UInt32(data.count)
        let lengthData = withUnsafeBytes(of: &length) { Data($0) }

        stdout.write(lengthData)
        stdout.write(data)
    }

    private func handleMessage(_ message: [String: Any]) {
        guard let type = message["type"] as? String else {
            return
        }

        switch type {
        case "getBlockedDomains":
            sendBlockedDomains()

        case "openApp":
            openMainApp()

        case "ping":
            sendMessage(["type": "pong"])

        default:
            log("Unknown message type: \\(type)")
        }
    }

    private func sendBlockedDomains() {
        // Read from shared config
        let configPath = "/Library/Application Support/FocusDragon/config.json"

        guard let data = try? Data(contentsOf: URL(fileURLWithPath: configPath)),
              let config = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            sendMessage([
                "type": "updateBlockedDomains",
                "domains": [],
                "isBlocking": false
            ])
            return
        }

        let domains = config["blockedDomains"] as? [String] ?? []
        let isBlocking = config["isBlocking"] as? Bool ?? false

        sendMessage([
            "type": "updateBlockedDomains",
            "domains": domains,
            "isBlocking": isBlocking
        ])
    }

    private func openMainApp() {
        NSWorkspace.shared.launchApplication("FocusDragon")
    }

    private func log(_ message: String) {
        let timestamp = Date()
        let logMessage = "[\\(timestamp)] \\(message)\\n"

        if let data = logMessage.data(using: .utf8) {
            stderr.write(data)
        }
    }
}

// Run host
let host = NativeMessagingHost()
host.start()
```

### Step 2: Chrome Native Messaging Manifest

Create `install-chrome-host.sh`:

```bash
#!/bin/bash

# Install Chrome native messaging host

CHROME_NATIVE_DIR="$HOME/Library/Application Support/Google/Chrome/NativeMessagingHosts"
mkdir -p "$CHROME_NATIVE_DIR"

cat > "$CHROME_NATIVE_DIR/com.focusdragon.nativehost.json" << 'EOF'
{
  "name": "com.focusdragon.nativehost",
  "description": "FocusDragon Native Messaging Host",
  "path": "/Applications/FocusDragon.app/Contents/MacOS/FocusDragonNativeHost",
  "type": "stdio",
  "allowed_origins": [
    "chrome-extension://EXTENSION_ID_HERE/"
  ]
}
EOF

echo "Chrome native messaging host installed"
echo "Replace EXTENSION_ID_HERE with actual extension ID"
```

### Step 3: Config Watcher

Watch for config changes and notify extensions:

```swift
class ConfigWatcher {
    private let configPath = "/Library/Application Support/FocusDragon/config.json"
    private var fileDescriptor: Int32 = -1
    private var source: DispatchSourceFileSystemObject?

    func startWatching(onChange: @escaping () -> Void) {
        fileDescriptor = open(configPath, O_EVTONLY)
        guard fileDescriptor >= 0 else { return }

        source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fileDescriptor,
            eventMask: .write,
            queue: DispatchQueue.global()
        )

        source?.setEventHandler {
            onChange()
        }

        source?.resume()
    }

    func stopWatching() {
        source?.cancel()
        if fileDescriptor >= 0 {
            close(fileDescriptor)
        }
    }
}
```

Update host to watch config:

```swift
class NativeMessagingHost {
    private var configWatcher: ConfigWatcher?

    func start() {
        // ... existing code ...

        // Watch config file
        configWatcher = ConfigWatcher()
        configWatcher?.startWatching { [weak self] in
            self?.sendBlockedDomains()
        }

        // ... existing code ...
    }
}
```

### Step 4: Build Native Host

Add build script to Xcode:

```bash
#!/bin/bash

# Build native messaging host

swiftc -o FocusDragonNativeHost FocusDragonNativeHost/main.swift

# Copy to app bundle
cp FocusDragonNativeHost FocusDragon.app/Contents/MacOS/

# Install manifests
./install-chrome-host.sh
./install-firefox-host.sh

echo "Native messaging host installed"
```

## Testing Criteria

### Test 1: Host Communication
1. Run host manually
2. Send JSON via stdin: `{"type":"ping"}`
3. **Expected:** Receives `{"type":"pong"}`

### Test 2: Extension Connection
1. Load Chrome extension
2. Check background console
3. **Expected:** "Connected to native host"

### Test 3: Domain Updates
1. Update config file
2. **Expected:** Extensions receive update
3. **Expected:** Blocking rules updated

### Test 4: Multiple Extensions
1. Connect Chrome + Firefox
2. Update config
3. **Expected:** Both receive updates

## Deliverables

✅ Native messaging host binary
✅ stdin/stdout protocol
✅ Chrome manifest
✅ Firefox manifest
✅ Config watcher
✅ Installation scripts

## Security Considerations

1. **Allowed origins** - Restrict to known extension IDs
2. **Input validation** - Sanitize all messages
3. **File permissions** - Config file protected
4. **No arbitrary execution** - Only specific commands

## Performance Notes

- Minimal memory usage (~2MB)
- Event-driven, no polling
- Instant message delivery

## Estimated Time

**2-3 hours**

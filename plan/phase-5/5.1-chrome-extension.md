# 5.1 Chrome Extension (Manifest V3)

**Objective:** Create Chrome extension using Manifest V3 to block websites with declarativeNetRequest API.

## Overview

Chrome Manifest V3 extension uses declarativeNetRequest for efficient website blocking. Communicates with native macOS app via native messaging.

## Project Structure

```
FocusDragonExtension-Chrome/
â”œâ”€â”€ manifest.json
â”œâ”€â”€ background.js
â”œâ”€â”€ popup/
â”‚   â”œâ”€â”€ popup.html
â”‚   â”œâ”€â”€ popup.css
â”‚   â””â”€â”€ popup.js
â”œâ”€â”€ blocked.html
â”œâ”€â”€ blocked.css
â”œâ”€â”€ icons/
â”‚   â”œâ”€â”€ icon16.png
â”‚   â”œâ”€â”€ icon48.png
â”‚   â””â”€â”€ icon128.png
â””â”€â”€ native-messaging-host.json
```

## Implementation Steps

### Step 1: Create Manifest V3 Configuration

Create `manifest.json`:

```json
{
  "manifest_version": 3,
  "name": "FocusDragon",
  "version": "1.0.0",
  "description": "Website blocker for deep focus",
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": [
    "declarativeNetRequest",
    "declarativeNetRequestFeedback",
    "storage",
    "nativeMessaging",
    "tabs"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png"
    }
  },
  "declarative_net_request": {
    "rule_resources": [
      {
        "id": "focusdragon_rules",
        "enabled": true,
        "path": "rules.json"
      }
    ]
  },
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'"
  }
}
```

### Step 2: Background Service Worker

Create `background.js`:

```javascript
// Background service worker for Chrome extension

const NATIVE_APP_NAME = "com.focusdragon.nativehost";
const STORAGE_KEY = "blockedDomains";
const RULE_ID_START = 1;

// Connect to native host
let nativePort = null;

function connectNative() {
  try {
    nativePort = chrome.runtime.connectNative(NATIVE_APP_NAME);

    nativePort.onMessage.addListener((message) => {
      console.log("Received from native:", message);
      handleNativeMessage(message);
    });

    nativePort.onDisconnect.addListener(() => {
      console.log("Native host disconnected");
      nativePort = null;

      // Retry connection after 5 seconds
      setTimeout(connectNative, 5000);
    });

    // Request current blocked domains
    nativePort.postMessage({ type: "getBlockedDomains" });
  } catch (error) {
    console.error("Failed to connect to native host:", error);
    nativePort = null;
  }
}

function handleNativeMessage(message) {
  switch (message.type) {
    case "updateBlockedDomains":
      updateBlockingRules(message.domains, message.isBlocking);
      break;

    case "blockStatus":
      updateExtensionIcon(message.isBlocking);
      break;

    default:
      console.warn("Unknown message type:", message.type);
  }
}

// Update blocking rules using declarativeNetRequest
async function updateBlockingRules(domains, isBlocking) {
  if (!isBlocking || domains.length === 0) {
    // Clear all rules
    await chrome.declarativeNetRequest.updateDynamicRules({
      removeRuleIds: await getAllRuleIds(),
    });

    await chrome.storage.local.set({ [STORAGE_KEY]: [] });
    updateExtensionIcon(false);
    return;
  }

  // Generate rules
  const rules = [];
  let ruleId = RULE_ID_START;

  for (const domain of domains) {
    // Block main domain
    rules.push({
      id: ruleId++,
      priority: 1,
      action: {
        type: "redirect",
        redirect: { extensionPath: "/blocked.html" },
      },
      condition: {
        urlFilter: `*://${domain}/*`,
        resourceTypes: ["main_frame"],
      },
    });

    // Block www variant
    if (!domain.startsWith("www.")) {
      rules.push({
        id: ruleId++,
        priority: 1,
        action: {
          type: "redirect",
          redirect: { extensionPath: "/blocked.html" },
        },
        condition: {
          urlFilter: `*://www.${domain}/*`,
          resourceTypes: ["main_frame"],
        },
      });
    }

    // Block subdomains
    rules.push({
      id: ruleId++,
      priority: 1,
      action: {
        type: "redirect",
        redirect: { extensionPath: "/blocked.html" },
      },
      condition: {
        urlFilter: `*://*.${domain}/*`,
        resourceTypes: ["main_frame"],
      },
    });
  }

  // Update rules
  try {
    await chrome.declarativeNetRequest.updateDynamicRules({
      removeRuleIds: await getAllRuleIds(),
      addRules: rules,
    });

    await chrome.storage.local.set({ [STORAGE_KEY]: domains });
    updateExtensionIcon(true);

    console.log(`Updated blocking rules for ${domains.length} domains`);
  } catch (error) {
    console.error("Failed to update rules:", error);
  }
}

async function getAllRuleIds() {
  const rules = await chrome.declarativeNetRequest.getDynamicRules();
  return rules.map((rule) => rule.id);
}

function updateExtensionIcon(isBlocking) {
  const iconPath = isBlocking ? "icons/icon-active" : "icons/icon";

  chrome.action.setIcon({
    path: {
      16: `${iconPath}16.png`,
      48: `${iconPath}48.png`,
    },
  });

  chrome.action.setBadgeText({
    text: isBlocking ? "ON" : "",
  });

  chrome.action.setBadgeBackgroundColor({
    color: isBlocking ? "#FF0000" : "#808080",
  });
}

// Prevent extension from being disabled
chrome.management.onDisabled.addListener((info) => {
  if (info.id === chrome.runtime.id) {
    console.warn("Extension disabled detected!");

    // Notify native host
    if (nativePort) {
      nativePort.postMessage({
        type: "extensionDisabled",
        browser: "chrome",
      });
    }

    // Try to re-enable (will fail, but worth trying)
    chrome.management.setEnabled(info.id, true, () => {
      console.log("Attempted to re-enable extension");
    });
  }
});

// Initialize
connectNative();

// Restore rules on startup
chrome.runtime.onStartup.addListener(async () => {
  console.log("Extension started");
  connectNative();
});

// Handle installation
chrome.runtime.onInstalled.addListener((details) => {
  console.log("Extension installed:", details.reason);

  if (details.reason === "install") {
    // First install
    chrome.tabs.create({
      url: "popup/welcome.html",
    });
  }
});
```

### Step 3: Popup UI

Create `popup/popup.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>FocusDragon</title>
    <link rel="stylesheet" href="popup.css" />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <img src="../icons/icon48.png" alt="FocusDragon" />
        <h1>FocusDragon</h1>
      </div>

      <div class="status">
        <div id="status-indicator" class="indicator"></div>
        <span id="status-text">Checking status...</span>
      </div>

      <div id="blocked-list" class="blocked-list"></div>

      <div class="footer">
        <p>Managed by FocusDragon app</p>
        <button id="open-app">Open App</button>
      </div>
    </div>

    <script src="popup.js"></script>
  </body>
</html>
```

Create `popup/popup.css`:

```css
body {
  width: 300px;
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.container {
  padding: 16px;
}

.header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.header img {
  width: 32px;
  height: 32px;
}

.header h1 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: #f5f5f5;
  border-radius: 8px;
  margin-bottom: 16px;
}

.indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #ccc;
}

.indicator.active {
  background: #ff0000;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.blocked-list {
  max-height: 200px;
  overflow-y: auto;
}

.blocked-item {
  padding: 8px;
  border-bottom: 1px solid #eee;
  font-size: 14px;
}

.blocked-item:last-child {
  border-bottom: none;
}

.footer {
  margin-top: 16px;
  text-align: center;
}

.footer p {
  font-size: 12px;
  color: #666;
  margin: 0 0 8px 0;
}

.footer button {
  background: #007aff;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.footer button:hover {
  background: #0051d5;
}
```

Create `popup/popup.js`:

```javascript
// Popup script
async function updateUI() {
  const { blockedDomains } = await chrome.storage.local.get("blockedDomains");
  const domains = blockedDomains || [];

  const statusIndicator = document.getElementById("status-indicator");
  const statusText = document.getElementById("status-text");
  const blockedList = document.getElementById("blocked-list");

  if (domains.length > 0) {
    statusIndicator.classList.add("active");
    statusText.textContent = `Blocking ${domains.length} site(s)`;

    blockedList.innerHTML = domains
      .map((domain) => `<div class="blocked-item">${domain}</div>`)
      .join("");
  } else {
    statusIndicator.classList.remove("active");
    statusText.textContent = "No blocking active";
    blockedList.innerHTML = '<div class="blocked-item">No sites blocked</div>';
  }
}

document.getElementById("open-app").addEventListener("click", () => {
  // Send message to native host to open app
  chrome.runtime.sendMessage({ type: "openApp" });
});

// Update UI on load
updateUI();

// Update UI when storage changes
chrome.storage.onChanged.addListener((changes) => {
  if (changes.blockedDomains) {
    updateUI();
  }
});
```

### Step 4: Blocked Page

Create `blocked.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Site Blocked - FocusDragon</title>
    <link rel="stylesheet" href="blocked.css" />
  </head>
  <body>
    <div class="container">
      <div class="icon">ğŸ‰</div>
      <h1>Site Blocked</h1>
      <p>This site is blocked by FocusDragon</p>
      <p class="subtitle">Stay focused on what matters</p>

      <div class="info">
        <p>To unblock this site, stop blocking in the FocusDragon app.</p>
      </div>
    </div>
  </body>
</html>
```

Create `blocked.css`:

```css
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
}

.container {
  text-align: center;
  max-width: 600px;
  padding: 40px;
}

.icon {
  font-size: 80px;
  margin-bottom: 20px;
}

h1 {
  font-size: 48px;
  font-weight: 700;
  margin: 0 0 16px 0;
}

p {
  font-size: 20px;
  margin: 8px 0;
  opacity: 0.9;
}

.subtitle {
  font-size: 16px;
  opacity: 0.7;
}

.info {
  margin-top: 40px;
  padding: 20px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.info p {
  font-size: 14px;
  margin: 0;
}
```

### Step 5: Build Script

Create `build.sh`:

```bash
#!/bin/bash

# Build Chrome extension

echo "Building FocusDragon Chrome Extension..."

# Create dist directory
mkdir -p dist

# Copy files
cp manifest.json dist/
cp background.js dist/
cp blocked.html dist/
cp blocked.css dist/
cp -r popup dist/
cp -r icons dist/

# Create empty rules.json
echo '[]' > dist/rules.json

echo "Build complete! Extension in dist/"
echo "Load unpacked extension from dist/ in Chrome"
```

## Testing Criteria

### Test 1: Extension Installation
1. Build extension
2. Load unpacked in Chrome
3. **Expected:** Appears in extensions list
4. **Expected:** Icon in toolbar

### Test 2: Native Messaging
1. Start FocusDragon app
2. Check extension background console
3. **Expected:** "Connected to native host"
4. **Expected:** No connection errors

### Test 3: Website Blocking
1. Add youtube.com to block list
2. Start blocking in app
3. Navigate to youtube.com in Chrome
4. **Expected:** Redirected to blocked.html
5. **Expected:** Shows "Site Blocked" message

### Test 4: Dynamic Updates
1. Add new domain while blocking active
2. **Expected:** Immediately blocks new domain
3. Remove domain
4. **Expected:** Immediately unblocks

### Test 5: Popup UI
1. Click extension icon
2. **Expected:** Shows blocked domains
3. **Expected:** Shows status indicator

### Test 6: Multiple Tabs
1. Block youtube.com
2. Open 5 YouTube tabs
3. **Expected:** All show blocked page

## Deliverables

âœ… Manifest V3 configuration
âœ… Background service worker
âœ… declarativeNetRequest rules
âœ… Native messaging integration
âœ… Popup UI
âœ… Blocked page
âœ… Build script

## Security Considerations

1. **declarativeNetRequest** - No content script needed
2. **Native messaging** - Secure app communication
3. **No eval()** - CSP compliant
4. **Minimal permissions** - Only what's needed

## Performance Notes

- declarativeNetRequest is highly efficient
- No content scripts = minimal overhead
- Rules evaluated in browser process
- ~0% CPU usage when idle

## Known Limitations

- Requires native messaging host
- Cannot block incognito (need permission)
- Users can disable extension (monitored)

## Next Steps

Move to [5.2-firefox-extension.md](./5.2-firefox-extension.md) for Firefox implementation.

## Estimated Time

**3-4 hours**

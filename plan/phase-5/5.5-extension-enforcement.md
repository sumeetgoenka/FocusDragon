# 5.5 Extension Enforcement

**Objective:** Detect and respond to extension disable attempts, ensure extensions remain active.

## Overview

Users may try to disable browser extensions to bypass blocking. Monitor extension state and take corrective actions.

## Implementation Steps

### Step 1: Extension State Monitor

Create `Services/ExtensionMonitor.swift`:

```swift
import Foundation

class ExtensionMonitor {
    static let shared = ExtensionMonitor()

    private var chromeExtensionActive = false
    private var firefoxExtensionActive = false
    private var safariExtensionActive = false

    private var timer: Timer?

    func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 10.0, repeats: true) { [weak self] _ in
            self?.checkExtensions()
        }

        checkExtensions()
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
    }

    private func checkExtensions() {
        checkChromeExtension()
        checkFirefoxExtension()
        checkSafariExtension()
    }

    private func checkChromeExtension() {
        // Try to communicate with Chrome extension
        let script = """
        tell application "System Events"
            set chromeRunning to (name of processes) contains "Google Chrome"
        end tell
        return chromeRunning
        """

        guard runAppleScript(script) == "true" else {
            chromeExtensionActive = false
            return
        }

        // Ping extension via native messaging
        pingChromeExtension()
    }

    private func pingChromeExtension() {
        // Extension will respond via native messaging
        // If no response in 5 seconds, assume inactive
    }

    private func checkFirefoxExtension() {
        // Similar to Chrome
        let script = """
        tell application "System Events"
            set firefoxRunning to (name of processes) contains "Firefox"
        end tell
        return firefoxRunning
        """

        guard runAppleScript(script) == "true" else {
            firefoxExtensionActive = false
            return
        }

        pingFirefoxExtension()
    }

    private func pingFirefoxExtension() {
        // Similar to Chrome
    }

    private func checkSafariExtension() {
        SFSafariExtensionManager.getStateOfSafariExtension(
            withIdentifier: "com.focusdragon.FocusDragonSafariExtension"
        ) { [weak self] state, error in
            if let state = state {
                self?.safariExtensionActive = state.isEnabled
                self?.handleSafariState(state)
            }
        }
    }

    private func handleSafariState(_ state: SFSafariExtensionState) {
        if !state.isEnabled {
            NotificationHelper.shared.showExtensionDisabled(browser: "Safari")
            promptEnableSafariExtension()
        }
    }

    private func promptEnableSafariExtension() {
        SFSafariApplication.showPreferencesForExtension(
            withIdentifier: "com.focusdragon.FocusDragonSafariExtension"
        )
    }

    private func runAppleScript(_ script: String) -> String {
        var error: NSDictionary?
        let appleScript = NSAppleScript(source: script)
        let result = appleScript?.executeAndReturnError(&error)

        return result?.stringValue ?? ""
    }

    var allExtensionsActive: Bool {
        return chromeExtensionActive || firefoxExtensionActive || safariExtensionActive
    }

    var activeExtensionCount: Int {
        var count = 0
        if chromeExtensionActive { count += 1 }
        if firefoxExtensionActive { count += 1 }
        if safariExtensionActive { count += 1 }
        return count
    }
}
```

### Step 2: Extension Health Check

Extensions send periodic heartbeats:

```javascript
// In extension background script
setInterval(() => {
  chrome.runtime.sendNativeMessage(NATIVE_APP_NAME, {
    type: "heartbeat",
    browser: "chrome",
    timestamp: Date.now(),
  });
}, 30000); // Every 30 seconds
```

Native host tracks last heartbeat:

```swift
class ExtensionHealthTracker {
    private var lastHeartbeats: [String: Date] = [:]
    private let timeout: TimeInterval = 60

    func recordHeartbeat(browser: String) {
        lastHeartbeats[browser] = Date()
    }

    func isExtensionHealthy(browser: String) -> Bool {
        guard let lastHeartbeat = lastHeartbeats[browser] else {
            return false
        }

        return Date().timeIntervalSince(lastHeartbeat) < timeout
    }
}
```

### Step 3: Enforcement Actions

When extension disabled during active block:

```swift
class ExtensionEnforcement {
    static let shared = ExtensionEnforcement()

    func handleExtensionDisabled(browser: String) {
        // Notify user
        NotificationHelper.shared.showExtensionDisabled(browser: browser)

        // Log attempt
        TamperDetection.shared.recordTamperAttempt()

        // If lock is active, show warning
        if LockManager.shared.currentLock.isLocked {
            showCriticalWarning(browser: browser)
        }

        // Fallback to hosts file blocking
        activateHostsFileBackup()
    }

    private func showCriticalWarning(browser: String) {
        let alert = NSAlert()
        alert.messageText = "Extension Disabled"
        alert.informativeText = """
        The FocusDragon \(browser) extension was disabled.

        Block is still active via other methods.

        Please re-enable the extension for best experience.
        """
        alert.alertStyle = .critical
        alert.runModal()
    }

    private func activateHostsFileBackup() {
        // Ensure hosts file blocking active as backup
        let domains = BlockListManager.shared.blockedItems
            .filter { $0.type == .website && $0.isEnabled }
            .map { $0.domain }

        try? HostsFileManager.shared.applyBlock(domains: domains)
    }
}
```

### Step 4: Extension Installation Verification

Check if extensions are installed:

```swift
class ExtensionInstallationChecker {
    static let shared = ExtensionInstallationChecker()

    struct ExtensionStatus {
        let browser: String
        let isInstalled: Bool
        let isEnabled: Bool
    }

    func checkAllExtensions() -> [ExtensionStatus] {
        return [
            checkChromeExtension(),
            checkFirefoxExtension(),
            checkSafariExtension()
        ]
    }

    private func checkChromeExtension() -> ExtensionStatus {
        // Check if Chrome native messaging manifest exists
        let manifestPath = "\\(NSHomeDirectory())/Library/Application Support/Google/Chrome/NativeMessagingHosts/com.focusdragon.nativehost.json"

        let isInstalled = FileManager.default.fileExists(atPath: manifestPath)

        return ExtensionStatus(
            browser: "Chrome",
            isInstalled: isInstalled,
            isEnabled: ExtensionMonitor.shared.chromeExtensionActive
        )
    }

    private func checkFirefoxExtension() -> ExtensionStatus {
        let manifestPath = "\\(NSHomeDirectory())/Library/Application Support/Mozilla/NativeMessagingHosts/com.focusdragon.nativehost.json"

        let isInstalled = FileManager.default.fileExists(atPath: manifestPath)

        return ExtensionStatus(
            browser: "Firefox",
            isInstalled: isInstalled,
            isEnabled: ExtensionMonitor.shared.firefoxExtensionActive
        )
    }

    private func checkSafariExtension() -> ExtensionStatus {
        // Safari extension is bundled, always installed
        return ExtensionStatus(
            browser: "Safari",
            isInstalled: true,
            isEnabled: ExtensionMonitor.shared.safariExtensionActive
        )
    }
}
```

### Step 5: Installation Helper UI

Create `Views/ExtensionInstallView.swift`:

```swift
import SwiftUI

struct ExtensionInstallView: View {
    @State private var extensionStatuses: [ExtensionInstallationChecker.ExtensionStatus] = []

    var body: some View {
        VStack(spacing: 20) {
            Text("Browser Extensions")
                .font(.title2)

            ForEach(extensionStatuses, id: \\.browser) { status in
                ExtensionRow(status: status)
            }

            Button("Refresh Status") {
                refreshStatuses()
            }
        }
        .padding()
        .onAppear {
            refreshStatuses()
        }
    }

    private func refreshStatuses() {
        extensionStatuses = ExtensionInstallationChecker.shared.checkAllExtensions()
    }
}

struct ExtensionRow: View {
    let status: ExtensionInstallationChecker.ExtensionStatus

    var body: some View {
        HStack {
            Image(systemName: browserIcon)
            Text(status.browser)

            Spacer()

            if status.isInstalled && status.isEnabled {
                Label("Active", systemImage: "checkmark.circle.fill")
                    .foregroundColor(.green)
            } else if status.isInstalled {
                Label("Disabled", systemImage: "exclamationmark.circle.fill")
                    .foregroundColor(.orange)
            } else {
                Label("Not Installed", systemImage: "xmark.circle.fill")
                    .foregroundColor(.red)
            }
        }
        .padding()
    }

    private var browserIcon: String {
        switch status.browser {
        case "Chrome": return "globe"
        case "Firefox": return "globe"
        case "Safari": return "safari"
        default: return "globe"
        }
    }
}
```

## Testing Criteria

### Test 1: Extension Disable Detection
1. Disable Chrome extension
2. **Expected:** Notification within 10 seconds
3. **Expected:** Tamper attempt recorded

### Test 2: Hosts File Fallback
1. Disable all extensions
2. **Expected:** Hosts file blocking activated
3. **Expected:** Sites still blocked

### Test 3: Re-enable Prompt
1. Disable Safari extension
2. **Expected:** Safari preferences opened
3. **Expected:** User prompted to re-enable

### Test 4: Heartbeat Monitoring
1. Kill extension process
2. Wait 60 seconds
3. **Expected:** Marked as unhealthy

## Deliverables

✅ Extension state monitor
✅ Heartbeat system
✅ Disable detection
✅ Enforcement actions
✅ Installation checker
✅ Helper UI

## Estimated Time

**2-3 hours**

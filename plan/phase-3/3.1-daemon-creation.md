# 3.1 LaunchDaemon Creation

**Objective:** Create a separate Swift executable that runs as a privileged background service.

## Overview

The daemon is the heart of FocusDragon's tamper resistance. It runs with root privileges, starts automatically on boot, and enforces blocks even when the main app is closed.

## Implementation Steps

### Step 1: Create Daemon Target in Xcode

1. **Add new target:**
   - File → New → Target
   - macOS → Command Line Tool
   - Name: `FocusDragonDaemon`
   - Language: Swift

2. **Configure build settings:**
   - Deployment Target: macOS 11.0
   - Architectures: Standard (Intel + Apple Silicon)
   - Code Signing: Automatic (or manual if using Developer ID)

3. **Add to main project:**
   - Ensure target is part of FocusDragon project
   - Share schemes for building

### Step 2: Create Daemon Entry Point

Create `FocusDragonDaemon/main.swift`:

```swift
#!/usr/bin/env swift

import Foundation

// Entry point for daemon
let daemon = DaemonService()

// Set up signal handlers for graceful shutdown
signal(SIGTERM) { signal in
    print("Received SIGTERM, shutting down gracefully...")
    daemon.stop()
    exit(0)
}

signal(SIGINT) { signal in
    print("Received SIGINT, shutting down...")
    daemon.stop()
    exit(0)
}

// Start the daemon
print("FocusDragon Daemon starting...")
daemon.start()

// Keep running
RunLoop.main.run()
```

### Step 3: Create DaemonService Class

Create `FocusDragonDaemon/DaemonService.swift`:

```swift
import Foundation

class DaemonService {
    // Configuration
    private let configPath = "/Library/Application Support/FocusDragon/config.json"
    private let logPath = "/var/log/focusdragon/daemon.log"

    // Watchers
    private var hostsWatcher: HostsWatcher?
    private var processWatcher: ProcessWatcher?
    private var configTimer: Timer?

    // State
    private var currentConfig: DaemonConfig?
    private var isRunning = false

    init() {
        setupLogging()
    }

    func start() {
        guard !isRunning else { return }
        isRunning = true

        log("Daemon started")

        // Create necessary directories
        createDirectories()

        // Load initial configuration
        loadConfiguration()

        // Start watchers
        startHostsWatcher()
        startProcessWatcher()

        // Poll for configuration changes
        startConfigurationPolling()

        log("All services started successfully")
    }

    func stop() {
        guard isRunning else { return }
        isRunning = false

        log("Stopping daemon...")

        // Stop watchers
        hostsWatcher?.stop()
        processWatcher?.stop()
        configTimer?.invalidate()

        log("Daemon stopped")
    }

    // MARK: - Configuration

    private func loadConfiguration() {
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: configPath)),
              let config = try? JSONDecoder().decode(DaemonConfig.self, from: data) else {
            log("No configuration found, using defaults")
            currentConfig = DaemonConfig()
            return
        }

        currentConfig = config
        log("Configuration loaded: \(config.blockedDomains.count) domains, \(config.blockedApps.count) apps")

        // Update watchers with new config
        updateWatchers()
    }

    private func startConfigurationPolling() {
        configTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { [weak self] _ in
            self?.checkForConfigChanges()
        }
    }

    private func checkForConfigChanges() {
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: configPath)),
              let newConfig = try? JSONDecoder().decode(DaemonConfig.self, from: data) else {
            return
        }

        // Check if config has changed
        if newConfig != currentConfig {
            log("Configuration changed, reloading...")
            currentConfig = newConfig
            updateWatchers()
        }
    }

    private func updateWatchers() {
        guard let config = currentConfig else { return }

        hostsWatcher?.updateDomains(config.blockedDomains, isBlocking: config.isBlocking)
        processWatcher?.updateApps(config.blockedApps, isBlocking: config.isBlocking)
    }

    // MARK: - Watchers

    private func startHostsWatcher() {
        hostsWatcher = HostsWatcher()
        if let config = currentConfig {
            hostsWatcher?.updateDomains(config.blockedDomains, isBlocking: config.isBlocking)
        }
        hostsWatcher?.start()
    }

    private func startProcessWatcher() {
        processWatcher = ProcessWatcher()
        if let config = currentConfig {
            processWatcher?.updateApps(config.blockedApps, isBlocking: config.isBlocking)
        }
        processWatcher?.start()
    }

    // MARK: - Utilities

    private func createDirectories() {
        let dirs = [
            "/Library/Application Support/FocusDragon",
            "/var/log/focusdragon"
        ]

        for dir in dirs {
            try? FileManager.default.createDirectory(
                atPath: dir,
                withIntermediateDirectories: true,
                attributes: nil
            )
        }
    }

    private func setupLogging() {
        // Redirect stdout to log file
        freopen(logPath, "a", stdout)
        freopen(logPath, "a", stderr)

        // Ensure unbuffered output
        setvbuf(stdout, nil, _IONBF, 0)
        setvbuf(stderr, nil, _IONBF, 0)
    }

    private func log(_ message: String) {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        print("[\(timestamp)] [DAEMON] \(message)")
    }
}
```

### Step 4: Create DaemonConfig Model

Add to `FocusDragonShared/SharedModels.swift`:

```swift
import Foundation

struct DaemonConfig: Codable, Equatable {
    var blockedDomains: [String] = []
    var blockedApps: [BlockedApp] = []
    var isBlocking: Bool = false
    var lockState: LockState?

    struct BlockedApp: Codable, Equatable {
        var bundleIdentifier: String
        var name: String
    }
}

struct LockState: Codable, Equatable {
    var isLocked: Bool
    var lockType: String
    var expiresAt: Date?
    var randomText: String?
    var requireRestart: Bool
}
```

### Step 5: Create LaunchDaemon Plist

Create `FocusDragonDaemon/com.focusdragon.daemon.plist`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- Unique identifier -->
    <key>Label</key>
    <string>com.focusdragon.daemon</string>

    <!-- Path to daemon executable -->
    <key>ProgramArguments</key>
    <array>
        <string>/Library/Application Support/FocusDragon/FocusDragonDaemon</string>
    </array>

    <!-- Run at system startup -->
    <key>RunAtLoad</key>
    <true/>

    <!-- Automatically restart if daemon exits -->
    <key>KeepAlive</key>
    <true/>

    <!-- Run as root -->
    <key>UserName</key>
    <string>root</string>

    <!-- Standard output log -->
    <key>StandardOutPath</key>
    <string>/var/log/focusdragon/daemon.log</string>

    <!-- Error log -->
    <key>StandardErrorPath</key>
    <string>/var/log/focusdragon/daemon-error.log</string>

    <!-- Prevent rapid restarts if crashing -->
    <key>ThrottleInterval</key>
    <integer>5</integer>

    <!-- Resource limits (prevent abuse) -->
    <key>HardResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>256</integer>
    </dict>

    <!-- Lower priority (don't interfere with system) -->
    <key>Nice</key>
    <integer>10</integer>
</dict>
</plist>
```

### Step 6: Build Daemon Executable

Create build script in `Scripts/build-daemon.sh`:

```bash
#!/bin/bash
set -e

echo "Building FocusDragon Daemon..."

# Build for both architectures
xcodebuild build \
    -project FocusDragon.xcodeproj \
    -scheme FocusDragonDaemon \
    -configuration Release \
    -derivedDataPath ./build \
    SYMROOT=./build

# Find the executable
DAEMON_PATH="build/Release/FocusDragonDaemon"

if [ ! -f "$DAEMON_PATH" ]; then
    echo "Error: Daemon executable not found at $DAEMON_PATH"
    exit 1
fi

echo "Daemon built successfully: $DAEMON_PATH"
echo "Size: $(du -h $DAEMON_PATH | cut -f1)"

# Make executable
chmod +x "$DAEMON_PATH"

echo "Ready to install!"
```

## Testing Criteria

### Test 1: Daemon Compiles
```bash
./Scripts/build-daemon.sh
```
**Expected:** Builds without errors

### Test 2: Daemon Runs Manually
```bash
sudo ./build/Release/FocusDragonDaemon
```
**Expected:**
- Starts without crashing
- Logs "Daemon started" to console
- Creates necessary directories

### Test 3: Configuration Loading
1. Create test config:
```bash
sudo mkdir -p "/Library/Application Support/FocusDragon"
cat > /tmp/config.json << EOF
{
  "blockedDomains": ["youtube.com"],
  "blockedApps": [],
  "isBlocking": true
}
EOF
sudo cp /tmp/config.json "/Library/Application Support/FocusDragon/"
```
2. Start daemon
3. **Expected:** Logs "Configuration loaded: 1 domains, 0 apps"

### Test 4: Graceful Shutdown
1. Start daemon
2. Send SIGTERM: `sudo kill -TERM <PID>`
3. **Expected:** Logs "Stopping daemon..." and exits cleanly

## Deliverables

✅ Daemon executable compiles successfully
✅ Runs as standalone process
✅ Loads configuration from JSON file
✅ Logs to `/var/log/focusdragon/daemon.log`
✅ Handles signals gracefully
✅ Creates necessary directories
✅ LaunchDaemon plist configured

## Security Considerations

- Daemon runs as root - keep code minimal
- Validate all configuration data
- Log all important actions
- Handle errors gracefully (don't crash)

## Next Steps

After 3.1 is complete, move to [3.2-hosts-file-protection.md](./3.2-hosts-file-protection.md) to implement hosts file monitoring.

## Estimated Time

**2-3 hours**

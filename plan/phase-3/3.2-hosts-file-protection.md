# 3.2 Hosts File Protection

**Objective:** Implement continuous monitoring and protection of `/etc/hosts` to prevent tampering.

## Overview

The HostsWatcher monitors `/etc/hosts` for unauthorized changes and automatically re-applies the FocusDragon block section if tampered with.

## Implementation Steps

### Step 1: Create HostsWatcher Class

Create `FocusDragonDaemon/HostsWatcher.swift`:

```swift
import Foundation

class HostsWatcher {
    private let hostsPath = "/etc/hosts"
    private let startMarker = "#### FocusDragon Block Start ####"
    private let endMarker = "#### FocusDragon Block End ####"

    private var blockedDomains: [String] = []
    private var isBlocking: Bool = false
    private var timer: Timer?
    private var lastModificationDate: Date?

    func start() {
        log("HostsWatcher started")

        // Store initial modification date
        updateLastModificationDate()

        // Start monitoring timer
        timer = Timer.scheduledTimer(
            withTimeInterval: 5.0,
            repeats: true
        ) { [weak self] _ in
            self?.checkHostsFile()
        }

        // Add to run loop
        if let timer = timer {
            RunLoop.main.add(timer, forMode: .common)
        }
    }

    func stop() {
        timer?.invalidate()
        timer = nil
        log("HostsWatcher stopped")
    }

    func updateDomains(_ domains: [String], isBlocking: Bool) {
        self.blockedDomains = domains
        self.isBlocking = isBlocking

        // Apply immediately
        if isBlocking {
            applyBlock()
        } else {
            removeBlock()
        }
    }

    // MARK: - Monitoring

    private func checkHostsFile() {
        guard isBlocking else { return }

        let currentDate = getModificationDate()

        // Check if file was modified
        if let last = lastModificationDate,
           let current = currentDate,
           current > last {
            log("Hosts file was modified externally!")
            handleTampering()
        }
    }

    private func handleTampering() {
        // Check if our block section is still present
        guard let content = readHostsFile(),
              content.contains(startMarker) else {
            log("Block section removed! Re-applying...")
            applyBlock()
            return
        }

        // Check if our entries are intact
        if !verifyBlockIntegrity() {
            log("Block section corrupted! Fixing...")
            applyBlock()
        }
    }

    private func verifyBlockIntegrity() -> Bool {
        guard let content = readHostsFile() else { return false }

        // Extract our block section
        guard let blockSection = extractBlockSection(from: content) else {
            return false
        }

        // Verify all domains are present
        for domain in blockedDomains {
            let entry = "0.0.0.0 \(domain)"
            if !blockSection.contains(entry) {
                log("Missing entry: \(entry)")
                return false
            }
        }

        return true
    }

    // MARK: - Block Management

    private func applyBlock() {
        guard isBlocking, !blockedDomains.isEmpty else { return }

        log("Applying hosts file block for \(blockedDomains.count) domains")

        // Read current hosts file
        guard var hostsContent = readHostsFile() else {
            log("ERROR: Could not read hosts file")
            return
        }

        // Remove existing block section
        hostsContent = removeBlockSection(from: hostsContent)

        // Generate new block section
        let blockSection = generateBlockSection()

        // Append block section
        hostsContent += "\n" + blockSection

        // Write to hosts file
        if writeHostsFile(content: hostsContent) {
            log("Hosts file updated successfully")
            flushDNSCache()
            updateLastModificationDate()
        } else {
            log("ERROR: Failed to write hosts file")
        }
    }

    private func removeBlock() {
        log("Removing hosts file block")

        guard var hostsContent = readHostsFile() else {
            log("ERROR: Could not read hosts file")
            return
        }

        hostsContent = removeBlockSection(from: hostsContent)

        if writeHostsFile(content: hostsContent) {
            log("Block removed successfully")
            flushDNSCache()
            updateLastModificationDate()
        }
    }

    private func generateBlockSection() -> String {
        var lines = [startMarker]

        for domain in blockedDomains {
            lines.append("0.0.0.0 \(domain)")

            // Also block www variant
            if !domain.hasPrefix("www.") {
                lines.append("0.0.0.0 www.\(domain)")
            }
        }

        lines.append(endMarker)
        return lines.joined(separator: "\n")
    }

    private func removeBlockSection(from content: String) -> String {
        guard let startRange = content.range(of: startMarker),
              let endRange = content.range(of: endMarker) else {
            return content
        }

        var cleaned = content
        let blockRange = startRange.lowerBound..<content.index(after: endRange.upperBound)
        cleaned.removeSubrange(blockRange)

        // Clean up extra newlines
        while cleaned.hasSuffix("\n\n\n") {
            cleaned = String(cleaned.dropLast())
        }

        return cleaned
    }

    private func extractBlockSection(from content: String) -> String? {
        guard let startRange = content.range(of: startMarker),
              let endRange = content.range(of: endMarker) else {
            return nil
        }

        let blockRange = startRange.upperBound..<endRange.lowerBound
        return String(content[blockRange])
    }

    // MARK: - File Operations

    private func readHostsFile() -> String? {
        return try? String(contentsOfFile: hostsPath, encoding: .utf8)
    }

    private func writeHostsFile(content: String) -> Bool {
        do {
            try content.write(toFile: hostsPath, atomically: true, encoding: .utf8)
            return true
        } catch {
            log("Write error: \(error)")
            return false
        }
    }

    private func getModificationDate() -> Date? {
        let attrs = try? FileManager.default.attributesOfItem(atPath: hostsPath)
        return attrs?[.modificationDate] as? Date
    }

    private func updateLastModificationDate() {
        lastModificationDate = getModificationDate()
    }

    private func flushDNSCache() {
        // macOS DNS cache flush
        let task = Process()
        task.launchPath = "/usr/bin/dscacheutil"
        task.arguments = ["-flushcache"]

        try? task.run()
        task.waitUntilExit()

        // Also kill mDNSResponder for good measure
        let killTask = Process()
        killTask.launchPath = "/usr/bin/killall"
        killTask.arguments = ["-HUP", "mDNSResponder"]

        try? killTask.run()
        killTask.waitUntilExit()

        log("DNS cache flushed")
    }

    // MARK: - Logging

    private func log(_ message: String) {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        print("[\(timestamp)] [HostsWatcher] \(message)")
    }
}
```

### Step 2: Handle File Permissions

Since daemon runs as root, it has permission to modify `/etc/hosts`. However, we should verify permissions:

```swift
extension HostsWatcher {
    private func verifyPermissions() -> Bool {
        let attrs = try? FileManager.default.attributesOfItem(atPath: hostsPath)

        guard let permissions = attrs?[.posixPermissions] as? NSNumber else {
            return false
        }

        // /etc/hosts should be 644 (rw-r--r--)
        let expected: UInt16 = 0o644
        return permissions.uint16Value == expected
    }

    private func fixPermissions() {
        let attrs: [FileAttributeKey: Any] = [
            .posixPermissions: NSNumber(value: 0o644)
        ]

        try? FileManager.default.setAttributes(attrs, ofItemAtPath: hostsPath)
        log("Permissions fixed")
    }
}
```

### Step 3: Add Backup Mechanism

Before first modification, create a backup:

```swift
extension HostsWatcher {
    private let backupPath = "/Library/Application Support/FocusDragon/hosts.backup"

    func createBackup() {
        guard !FileManager.default.fileExists(atPath: backupPath) else {
            log("Backup already exists")
            return
        }

        do {
            try FileManager.default.copyItem(atPath: hostsPath, toPath: backupPath)
            log("Hosts file backed up to \(backupPath)")
        } catch {
            log("Backup failed: \(error)")
        }
    }

    func restoreBackup() {
        guard FileManager.default.fileExists(atPath: backupPath) else {
            log("No backup to restore")
            return
        }

        do {
            try FileManager.default.copyItem(atPath: backupPath, toPath: hostsPath)
            flushDNSCache()
            log("Hosts file restored from backup")
        } catch {
            log("Restore failed: \(error)")
        }
    }
}
```

### Step 4: Integrate with DaemonService

Update `DaemonService.swift`:

```swift
private func startHostsWatcher() {
    hostsWatcher = HostsWatcher()

    // Create backup before first use
    hostsWatcher?.createBackup()

    // Apply current configuration
    if let config = currentConfig {
        hostsWatcher?.updateDomains(config.blockedDomains, isBlocking: config.isBlocking)
    }

    hostsWatcher?.start()
}
```

## Testing Criteria

### Test 1: Block Application
1. Start daemon with blocking enabled
2. Check `/etc/hosts`
3. **Expected:** Contains FocusDragon block section with all domains

### Test 2: Tamper Detection (Manual Edit)
1. Start daemon with blocking enabled
2. Manually edit `/etc/hosts` and remove a line from block section
3. Wait 5 seconds
4. Check `/etc/hosts` again
5. **Expected:** Block section restored within 5 seconds

### Test 3: Tamper Detection (Complete Removal)
1. Start daemon with blocking enabled
2. Manually remove entire FocusDragon block section
3. Wait 5 seconds
4. **Expected:** Block section re-added

### Test 4: DNS Flush
1. Add domain to block
2. Before block: `ping youtube.com` → resolves to real IP
3. Apply block
4. After block: `ping youtube.com` → resolves to 0.0.0.0
5. **Expected:** No caching delay

### Test 5: Backup Creation
1. Start daemon for first time
2. **Expected:** Backup file exists at `/Library/Application Support/FocusDragon/hosts.backup`
3. **Expected:** Backup is exact copy of original

### Test 6: Block Removal
1. Start daemon with blocking enabled
2. Update config to `isBlocking: false`
3. Wait 2 seconds (config poll interval)
4. **Expected:** FocusDragon section removed from `/etc/hosts`

## Deliverables

✅ HostsWatcher class implemented
✅ Monitors hosts file every 5 seconds
✅ Re-applies block if tampered
✅ Creates backup before first modification
✅ Flushes DNS cache after changes
✅ Handles www variants automatically
✅ Logs all actions

## Performance Notes

- Check interval: 5 seconds (balance between responsiveness and CPU)
- File read: ~1ms for typical hosts file
- File write: ~5ms including DNS flush
- CPU impact: <0.1% average

## Security Considerations

- Running as root allows modification of `/etc/hosts`
- Always validate domain format before writing
- Never write user input directly to file
- Create backup to allow recovery
- Log all modifications for audit

## Known Issues

**Issue:** Brief window between tamper and detection
**Impact:** ~5 seconds where tampered hosts file is active
**Mitigation:** Acceptable - users would need perfect timing

**Issue:** Backup created on first run only
**Impact:** If original hosts file changes later, backup is outdated
**Status:** Document that backup is from first install

## Next Steps

Move to [3.3-process-monitoring-daemon.md](./3.3-process-monitoring-daemon.md) to implement app blocking in the daemon.

## Estimated Time

**2-3 hours**

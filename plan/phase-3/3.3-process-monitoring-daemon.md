# 3.3 Process Monitoring in Daemon

**Objective:** Move process monitoring from the main app to the daemon for persistent app blocking.

## Overview

By moving process monitoring to the daemon, blocked apps stay terminated even when the main FocusDragon app is closed. The daemon runs 24/7 as root, making it impossible for users to stop monitoring without admin access.

## Implementation Steps

### Step 1: Create ProcessWatcher Class

Create `FocusDragonDaemon/ProcessWatcher.swift`:

```swift
import Foundation
import AppKit

class ProcessWatcher {
    private var blockedBundleIDs: Set<String> = []
    private var isBlocking: Bool = false
    private var timer: Timer?
    private var terminationCount: [String: Int] = [:]

    // System apps that should NEVER be killed
    private let protectedApps: Set<String> = [
        "com.apple.finder",
        "com.apple.systemuiserver",
        "com.apple.dock",
        "com.apple.loginwindow",
        "com.apple.WindowManager",
        "com.apple.Spotlight"
    ]

    func start() {
        log("ProcessWatcher started")

        timer = Timer.scheduledTimer(
            withTimeInterval: 1.5,
            repeats: true
        ) { [weak self] _ in
            self?.checkRunningProcesses()
        }

        if let timer = timer {
            RunLoop.main.add(timer, forMode: .common)
        }
    }

    func stop() {
        timer?.invalidate()
        timer = nil
        log("ProcessWatcher stopped")
    }

    func updateApps(_ apps: [DaemonConfig.BlockedApp], isBlocking: Bool) {
        self.isBlocking = isBlocking

        blockedBundleIDs = Set(apps.map { $0.bundleIdentifier })
        blockedBundleIDs.subtract(protectedApps)

        log("Updated block list: \(blockedBundleIDs.count) apps")
    }

    // MARK: - Process Monitoring

    private func checkRunningProcesses() {
        guard isBlocking, !blockedBundleIDs.isEmpty else { return }

        let runningApps = NSWorkspace.shared.runningApplications

        for app in runningApps {
            guard let bundleID = app.bundleIdentifier else { continue }

            if blockedBundleIDs.contains(bundleID) {
                terminateApp(app, bundleID: bundleID)
            }
        }
    }

    private func terminateApp(_ app: NSRunningApplication, bundleID: String) {
        let appName = app.localizedName ?? bundleID

        log("Terminating: \(appName) (\(bundleID))")

        // Increment termination count
        terminationCount[bundleID, default: 0] += 1

        // Try graceful termination first
        let terminated = app.terminate()

        if !terminated {
            // If graceful fails, schedule force kill
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in
                if app.isRunning {
                    self?.forceKill(app, appName: appName)
                }
            }
        } else {
            log("Gracefully terminated: \(appName)")
        }
    }

    private func forceKill(_ app: NSRunningApplication, appName: String) {
        let pid = app.processIdentifier
        let result = kill(pid, SIGKILL)

        if result == 0 {
            log("Force killed: \(appName) (PID: \(pid))")
        } else {
            log("Failed to kill: \(appName) (PID: \(pid), errno: \(errno))")
        }
    }

    // MARK: - Statistics

    func getStatistics() -> [String: Int] {
        return terminationCount
    }

    func resetStatistics() {
        terminationCount.removeAll()
    }

    // MARK: - Logging

    private func log(_ message: String) {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        print("[\(timestamp)] [ProcessWatcher] \(message)")
    }
}
```

### Step 2: Add Process Enumeration

For better reliability, also check processes via `ps`:

```swift
extension ProcessWatcher {
    private func getAllProcesses() -> [ProcessInfo] {
        var processes: [ProcessInfo] = []

        // Use sysctl to get process list
        var mib: [Int32] = [CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0]
        var size: size_t = 0

        // Get size needed
        sysctl(&mib, u_int(mib.count), nil, &size, nil, 0)

        let count = size / MemoryLayout<kinfo_proc>.stride
        var procs = [kinfo_proc](repeating: kinfo_proc(), count: count)

        // Get actual data
        sysctl(&mib, u_int(mib.count), &procs, &size, nil, 0)

        for proc in procs {
            let pid = proc.kp_proc.p_pid
            if pid > 0 {
                let name = withUnsafePointer(to: proc.kp_proc.p_comm) {
                    String(cString: UnsafeRawPointer($0).assumingMemoryBound(to: CChar.self))
                }

                processes.append(ProcessInfo(pid: pid, name: name))
            }
        }

        return processes
    }

    private struct ProcessInfo {
        let pid: pid_t
        let name: String
    }
}
```

### Step 3: Handle Launch Agents/Daemons

Some apps have launch agents that auto-restart them. Detect and handle:

```swift
extension ProcessWatcher {
    private var respawnDetection: [String: Date] = [:]

    private func terminateApp(_ app: NSRunningApplication, bundleID: String) {
        // ... existing code ...

        // Check for rapid respawning
        if let lastTermination = respawnDetection[bundleID],
           Date().timeIntervalSince(lastTermination) < 10 {
            log("WARNING: \(bundleID) is respawning rapidly")
            handleRespawning(bundleID)
        }

        respawnDetection[bundleID] = Date()

        // ... rest of termination code ...
    }

    private func handleRespawning(_ bundleID: String) {
        // Try to find and disable launch agent
        let possiblePaths = [
            "/Library/LaunchAgents/\(bundleID).plist",
            "/Library/LaunchDaemons/\(bundleID).plist",
            NSHomeDirectory() + "/Library/LaunchAgents/\(bundleID).plist"
        ]

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path) {
                log("Found launch agent at: \(path)")
                // Could unload it, but that's aggressive
                // For now, just log it
            }
        }
    }
}
```

### Step 4: Integrate with DaemonService

Update `DaemonService.swift`:

```swift
private func startProcessWatcher() {
    processWatcher = ProcessWatcher()

    if let config = currentConfig {
        processWatcher?.updateApps(config.blockedApps, isBlocking: config.isBlocking)
    }

    processWatcher?.start()
}
```

## Testing Criteria

### Test 1: Basic App Blocking
1. Add Steam to block list
2. Set `isBlocking: true` in config
3. Launch Steam
4. **Expected:** Steam terminates within 2 seconds

### Test 2: Persistence After App Close
1. Block Steam in main app
2. Quit FocusDragon.app
3. Launch Steam
4. **Expected:** Steam still terminates (daemon continues monitoring)

### Test 3: Multiple Apps
1. Block Steam, Discord, Spotify
2. Launch all three
3. **Expected:** All terminate independently

### Test 4: System App Protection
1. Add Finder to block list
2. **Expected:** Finder is NOT in blockedBundleIDs (filtered out)

### Test 5: Graceful vs Force Kill
1. Block TextEdit
2. Open TextEdit with unsaved document
3. **Expected:** Save dialog appears (graceful termination)
4. Click "Cancel"
5. **Expected:** After 2 seconds, force killed

### Test 6: Rapid Respawning
1. Block an app with launch agent
2. **Expected:** Logs "respawning rapidly" warning
3. **Expected:** Continues terminating on each spawn

### Test 7: Statistics
1. Block and launch Steam 5 times
2. Check daemon statistics
3. **Expected:** Termination count for Steam = 5

## Deliverables

✅ ProcessWatcher class in daemon
✅ Monitors processes every 1.5 seconds
✅ Graceful termination with force kill fallback
✅ System app protection
✅ Respawn detection
✅ Statistics tracking
✅ Works when main app closed

## Performance Notes

- Check interval: 1.5 seconds
- ~100 processes on average Mac
- Enumeration: <5ms
- Total CPU: <2% average

## Security Considerations

- Running as root allows killing any process
- Protected apps list prevents system damage
- Log all terminations for audit
- Don't kill critical system processes

## Known Issues

**Issue:** Brief flash when app launches
**Impact:** User sees app icon appear before termination
**Mitigation:** Unavoidable with polling approach
**Status:** Acceptable (~1.5 second window)

**Issue:** Some apps resist termination
**Impact:** Rare, usually daemon-type apps
**Mitigation:** Force kill after timeout
**Status:** Working as designed

## Next Steps

Move to [3.4-daemon-installation.md](./3.4-daemon-installation.md) to create installation process.

## Estimated Time

**2-3 hours**

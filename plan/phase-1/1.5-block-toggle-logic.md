# 1.5 Block Toggle Logic & Testing

**Objective:** Finalize the start/stop block functionality with proper error handling and state persistence.

## Implementation Tasks

### Task 1: Enhanced Error Handling

Update `Views/MainView.swift` with better error handling:

```swift
import SwiftUI

struct MainView: View {
    @StateObject private var manager = BlockListManager()
    @State private var newDomain: String = ""
    @State private var errorMessage: String?
    @State private var showingError = false
    @State private var isProcessing = false

    var body: some View {
        VStack(spacing: 20) {
            // ... existing UI code ...

            // Status indicator
            HStack {
                Circle()
                    .fill(manager.isBlocking ? Color.green : Color.gray)
                    .frame(width: 12, height: 12)
                Text(manager.isBlocking ? "Blocking Active" : "Not Blocking")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            // Control buttons
            HStack(spacing: 20) {
                Button(manager.isBlocking ? "Stop Block" : "Start Block") {
                    toggleBlocking()
                }
                .buttonStyle(.borderedProminent)
                .tint(manager.isBlocking ? .red : .green)
                .disabled(isProcessing || manager.blockedItems.isEmpty)
            }
            .padding()
        }
        .frame(minWidth: 500, minHeight: 400)
        .padding()
        .alert("Error", isPresented: $showingError) {
            Button("OK") { }
        } message: {
            Text(errorMessage ?? "Unknown error occurred")
        }
    }

    private func toggleBlocking() {
        isProcessing = true

        Task {
            do {
                if manager.isBlocking {
                    try await stopBlocking()
                } else {
                    try await startBlocking()
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showingError = true
                }
            }

            await MainActor.run {
                isProcessing = false
            }
        }
    }

    private func startBlocking() async throws {
        let enabledDomains = manager.blockedItems
            .filter { $0.isEnabled }
            .map { $0.domain }

        guard !enabledDomains.isEmpty else {
            throw BlockError.noDomains
        }

        // Request admin privileges
        let hasPrivileges = await requestPrivileges()
        guard hasPrivileges else {
            throw BlockError.privilegesDenied
        }

        // Apply block
        try HostsFileManager.shared.applyBlock(domains: enabledDomains)

        await MainActor.run {
            manager.isBlocking = true
        }
    }

    private func stopBlocking() async throws {
        try HostsFileManager.shared.removeBlock()

        await MainActor.run {
            manager.isBlocking = false
        }
    }

    private func requestPrivileges() async -> Bool {
        // Run privilege request on background thread
        return await Task.detached {
            HostsFileManager.shared.requestAdminPrivileges()
        }.value
    }
}

enum BlockError: LocalizedError {
    case noDomains
    case privilegesDenied

    var errorDescription: String? {
        switch self {
        case .noDomains:
            return "No domains enabled for blocking"
        case .privilegesDenied:
            return "Administrator privileges are required to modify the hosts file"
        }
    }
}
```

### Task 2: State Persistence

Add persistence to remember block list between app launches:

```swift
import Foundation

class BlockListManager: ObservableObject {
    @Published var blockedItems: [BlockItem] = []
    @Published var isBlocking: Bool = false

    private let userDefaults = UserDefaults.standard
    private let blockedItemsKey = "blockedItems"
    private let isBlockingKey = "isBlocking"

    init() {
        loadState()
    }

    func addDomain(_ domain: String) {
        let cleaned = domain.lowercased().trimmingCharacters(in: .whitespaces)
        guard cleaned.isValidDomain else { return }

        let item = BlockItem(domain: cleaned)
        blockedItems.append(item)
        saveState()
    }

    func removeDomain(at offsets: IndexSet) {
        blockedItems.remove(atOffsets: offsets)
        saveState()
    }

    func toggleDomain(id: UUID) {
        if let index = blockedItems.firstIndex(where: { $0.id == id }) {
            blockedItems[index].isEnabled.toggle()
            saveState()
        }
    }

    private func saveState() {
        if let encoded = try? JSONEncoder().encode(blockedItems) {
            userDefaults.set(encoded, forKey: blockedItemsKey)
        }
        userDefaults.set(isBlocking, forKey: isBlockingKey)
    }

    private func loadState() {
        if let data = userDefaults.data(forKey: blockedItemsKey),
           let decoded = try? JSONDecoder().decode([BlockItem].self, from: data) {
            blockedItems = decoded
        }
        isBlocking = userDefaults.bool(forKey: isBlockingKey)
    }
}
```

### Task 3: Input Validation UI

Add validation feedback when adding domains:

```swift
// Add these states to MainView
@State private var domainValidationError: String?

// Update the add domain section
HStack {
    TextField("Enter domain (e.g., youtube.com)", text: $newDomain)
        .textFieldStyle(.roundedBorder)
        .onChange(of: newDomain) { _ in
            domainValidationError = nil
        }

    Button("Add") {
        addDomain()
    }
    .buttonStyle(.borderedProminent)
    .disabled(newDomain.isEmpty)
}
.padding(.horizontal)

if let error = domainValidationError {
    Text(error)
        .font(.caption)
        .foregroundColor(.red)
        .padding(.horizontal)
}

// Add validation method
private func addDomain() {
    let cleaned = newDomain.lowercased().trimmingCharacters(in: .whitespaces)

    guard !cleaned.isEmpty else { return }

    guard cleaned.isValidDomain else {
        domainValidationError = "Invalid domain format. Use: example.com"
        return
    }

    if manager.blockedItems.contains(where: { $0.domain == cleaned }) {
        domainValidationError = "Domain already in block list"
        return
    }

    manager.addDomain(cleaned)
    newDomain = ""
    domainValidationError = nil
}
```

### Task 4: Verify Blocking on Startup

Add a check when the app launches to verify if blocking should be active:

```swift
// In MainView
.onAppear {
    verifyBlockingState()
}

private func verifyBlockingState() {
    // Check if hosts file has our markers
    let hostsContent = try? String(contentsOfFile: "/etc/hosts", encoding: .utf8)
    let hasMarkers = hostsContent?.contains("#### FocusDragon Block Start ####") ?? false

    if manager.isBlocking && !hasMarkers {
        // Block should be active but isn't - reapply
        Task {
            try? await startBlocking()
        }
    } else if !manager.isBlocking && hasMarkers {
        // Block shouldn't be active but is - remove
        Task {
            try? await stopBlocking()
        }
    }
}
```

## Testing Criteria

Create a comprehensive test plan:

### Test 1: Basic Blocking
1. Launch app
2. Add `youtube.com` to block list
3. Click "Start Block"
4. Enter admin password
5. **Expected:** YouTube inaccessible in Safari
6. Click "Stop Block"
7. **Expected:** YouTube accessible again

### Test 2: Multiple Domains
1. Add multiple domains: `youtube.com`, `facebook.com`, `twitter.com`
2. Start block
3. **Expected:** All three sites blocked
4. Disable `facebook.com` toggle
5. Restart block
6. **Expected:** YouTube and Twitter blocked, Facebook accessible

### Test 3: Invalid Input
1. Try to add `not a domain!@#`
2. **Expected:** Error message shown
3. Try to add `youtube.com` twice
4. **Expected:** Duplicate error shown

### Test 4: Persistence
1. Add domains and enable blocking
2. Quit app
3. Relaunch app
4. **Expected:** Domains still in list, blocking status maintained
5. Sites should still be blocked

### Test 5: Permission Denial
1. Add domain
2. Click "Start Block"
3. Click "Cancel" on password prompt
4. **Expected:** Error alert shown, blocking not enabled

### Test 6: Hosts File Integrity
1. Start blocking
2. In Terminal: `cat /etc/hosts`
3. **Expected:** See FocusDragon markers with correct domains
4. Stop blocking
5. Check hosts file again
6. **Expected:** Markers removed, file intact

### Test 7: DNS Flush
1. Start blocking
2. In Terminal: `ping youtube.com`
3. **Expected:** Resolves to 0.0.0.0 or fails
4. Stop blocking
5. `ping youtube.com` again
6. **Expected:** Resolves to actual IP immediately

## Deliverables

✅ Working Mac app that blocks websites via hosts file
✅ Clean SwiftUI interface with error handling
✅ State persistence between launches
✅ Input validation and user feedback
✅ Proper admin privilege handling
✅ DNS cache flushing
✅ Status indicators

## Security Considerations

1. **Never write user input directly to hosts file** - always validate
2. **Preserve existing hosts entries** - only modify FocusDragon section
3. **Backup mechanism** - consider creating backup before first modification
4. **Sanitize domains** - remove special characters, convert to lowercase

## Phase 1 Complete Checklist

- [ ] Xcode and environment set up
- [ ] Project initialized with proper structure
- [ ] SwiftUI interface complete and functional
- [ ] Hosts file manipulation working
- [ ] Block toggle logic implemented
- [ ] Error handling comprehensive
- [ ] State persistence working
- [ ] All tests pass
- [ ] Code is clean and documented
- [ ] Ready to commit to git

## Known Issues & Limitations

1. **Requires password every time** - Phase 3 will add LaunchDaemon to avoid this
2. **Blocking stops when app quits** - Will be fixed with background service
3. **Can be bypassed by editing hosts file manually** - Tamper resistance in Phase 4
4. **No application blocking yet** - Coming in Phase 2

## Next Steps

After Phase 1 is complete and tested:
- Commit all code to git with message: "Phase 1: Basic website blocking complete"
- Move to **Phase 2: Application Blocking**

## Estimated Time for Phase 1

**Total: 4-6 hours** (for someone familiar with Swift/SwiftUI)

- Section 1.1: 30-60 minutes
- Section 1.2: 20-30 minutes
- Section 1.3: 1-2 hours
- Section 1.4: 2-3 hours
- Section 1.5: 1 hour

# 2.2 Process Monitoring & Termination

**Objective:** Implement background monitoring to detect and terminate blocked applications.

## Overview

The process monitor runs continuously, checking every 1-2 seconds for blocked applications and terminating them immediately.

## Implementation Steps

### Step 1: Create ProcessMonitor Service

Create `Services/ProcessMonitor.swift`:

```swift
import Foundation
import AppKit

class ProcessMonitor: ObservableObject {
    static let shared = ProcessMonitor()

    private var timer: Timer?
    private var blockedBundleIDs: Set<String> = []
    @Published var isMonitoring = false
    @Published var terminationCount = 0

    // Apps that should NEVER be terminated (safety)
    private let systemProtectedApps: Set<String> = [
        "com.apple.finder",
        "com.apple.systemuiserver",
        "com.apple.dock",
        "com.apple.loginwindow",
        "com.apple.WindowManager"
    ]

    private init() {}

    func startMonitoring(blockedApps: [BlockItem]) {
        stopMonitoring()

        // Extract bundle IDs
        blockedBundleIDs = Set(blockedApps
            .filter { $0.type == .application && $0.isEnabled }
            .compactMap { $0.bundleIdentifier })

        // Remove any system protected apps
        blockedBundleIDs.subtract(systemProtectedApps)

        guard !blockedBundleIDs.isEmpty else { return }

        isMonitoring = true

        // Start timer
        timer = Timer.scheduledTimer(
            withTimeInterval: 1.5,
            repeats: true
        ) { [weak self] _ in
            self?.checkRunningProcesses()
        }

        // Add to run loop to ensure it fires
        if let timer = timer {
            RunLoop.main.add(timer, forMode: .common)
        }

        print("ProcessMonitor: Started monitoring \(blockedBundleIDs.count) apps")
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
        blockedBundleIDs.removeAll()
        print("ProcessMonitor: Stopped monitoring")
    }

    private func checkRunningProcesses() {
        let runningApps = NSWorkspace.shared.runningApplications

        for app in runningApps {
            guard let bundleId = app.bundleIdentifier else { continue }

            if blockedBundleIDs.contains(bundleId) {
                terminateApplication(app)
            }
        }
    }

    private func terminateApplication(_ app: NSRunningApplication) {
        let appName = app.localizedName ?? "Unknown"
        print("ProcessMonitor: Terminating \(appName) (\(app.bundleIdentifier ?? ""))")

        // Try graceful termination first
        let terminated = app.terminate()

        // If graceful fails, force kill after 2 seconds
        if !terminated {
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                if app.isRunning {
                    let pid = app.processIdentifier
                    kill(pid, SIGKILL)
                    print("ProcessMonitor: Force killed PID \(pid)")
                }
            }
        }

        terminationCount += 1

        // Send notification
        NotificationHelper.shared.showBlockedAppNotification(appName: appName)
    }

    func updateBlockedApps(_ apps: [BlockItem]) {
        if isMonitoring {
            // Restart with new list
            startMonitoring(blockedApps: apps)
        }
    }
}
```

### Step 2: Create Notification Helper

Create `Utilities/NotificationHelper.swift`:

```swift
import Foundation
import UserNotifications

class NotificationHelper {
    static let shared = NotificationHelper()

    private init() {
        requestAuthorization()
    }

    func requestAuthorization() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) { granted, error in
            if let error = error {
                print("Notification authorization error: \(error)")
            }
        }
    }

    func showBlockedAppNotification(appName: String) {
        let content = UNMutableNotificationContent()
        content.title = "Application Blocked"
        content.body = "\(appName) was blocked by FocusDragon"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("Notification error: \(error)")
            }
        }
    }

    func showBlockingStarted() {
        let content = UNMutableNotificationContent()
        content.title = "FocusDragon Active"
        content.body = "Blocking is now active"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }

    func showBlockingStopped() {
        let content = UNMutableNotificationContent()
        content.title = "FocusDragon Inactive"
        content.body = "Blocking has been stopped"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }
}
```

### Step 3: Integrate with Main View

Update `Views/MainView.swift` to start/stop process monitoring:

```swift
private func startBlocking() async throws {
    let enabledDomains = manager.blockedItems
        .filter { $0.isEnabled && $0.type == .website }
        .compactMap { $0.domain }

    let enabledApps = manager.blockedItems
        .filter { $0.isEnabled && $0.type == .application }

    guard !enabledDomains.isEmpty || !enabledApps.isEmpty else {
        throw BlockError.noDomains
    }

    // Request admin privileges if needed
    if !enabledDomains.isEmpty {
        let hasPrivileges = await requestPrivileges()
        guard hasPrivileges else {
            throw BlockError.privilegesDenied
        }
        try HostsFileManager.shared.applyBlock(domains: enabledDomains)
    }

    // Start process monitoring for apps
    if !enabledApps.isEmpty {
        await MainActor.run {
            ProcessMonitor.shared.startMonitoring(blockedApps: enabledApps)
        }
    }

    await MainActor.run {
        manager.isBlocking = true
        NotificationHelper.shared.showBlockingStarted()
    }
}

private func stopBlocking() async throws {
    // Stop process monitoring
    ProcessMonitor.shared.stopMonitoring()

    // Remove hosts file blocks
    try HostsFileManager.shared.removeBlock()

    await MainActor.run {
        manager.isBlocking = false
        NotificationHelper.shared.showBlockingStopped()
    }
}
```

### Step 4: Add Statistics Tracking

Create `Models/BlockStats.swift`:

```swift
import Foundation

struct BlockStats: Codable {
    var totalAppsBlocked: Int = 0
    var totalWebsitesBlocked: Int = 0
    var blockingSessions: Int = 0
    var lastBlockDate: Date?

    mutating func incrementAppBlocks() {
        totalAppsBlocked += 1
    }

    mutating func incrementWebsiteBlocks() {
        totalWebsitesBlocked += 1
    }

    mutating func startSession() {
        blockingSessions += 1
        lastBlockDate = Date()
    }
}
```

Update `BlockListManager` to track stats:

```swift
@Published var stats = BlockStats()

private let statsKey = "blockStats"

func startBlockingSession() {
    stats.startSession()
    saveState()
}

private func saveState() {
    // ... existing code ...
    if let encoded = try? JSONEncoder().encode(stats) {
        userDefaults.set(encoded, forKey: statsKey)
    }
}

private func loadState() {
    // ... existing code ...
    if let data = userDefaults.data(forKey: statsKey),
       let decoded = try? JSONDecoder().decode(BlockStats.self, from: data) {
        stats = decoded
    }
}
```

## Testing Criteria

### Test 1: Basic App Blocking
1. Add Steam to block list
2. Start blocking
3. Launch Steam
4. **Expected:** Steam terminates within 2 seconds
5. **Expected:** Notification appears

### Test 2: Multiple Apps
1. Block Steam, Discord, and Spotify
2. Start blocking
3. Launch all three apps
4. **Expected:** All three terminate quickly

### Test 3: Graceful Termination
1. Block TextEdit
2. Open TextEdit with unsaved document
3. Start blocking
4. **Expected:** TextEdit shows save dialog first

### Test 4: Force Kill
1. Block an app that resists termination
2. **Expected:** Gets force killed after 2 seconds

### Test 5: System Protection
1. Try to add Finder to block list
2. **Expected:** Works but doesn't actually kill Finder

### Test 6: Monitoring Performance
1. Block 10+ apps
2. Start blocking
3. **Expected:** CPU usage remains low
4. **Expected:** No lag in UI

### Test 7: Stop Monitoring
1. Start blocking with apps
2. Stop blocking
3. Launch previously blocked app
4. **Expected:** App runs normally

## Deliverables

✅ Process monitoring service
✅ App termination (graceful + force)
✅ System app protection
✅ Notifications for blocked apps
✅ Statistics tracking
✅ Integration with main app

## Security Considerations

1. **Never terminate system apps** - Maintain protected list
2. **Graceful termination first** - Give apps chance to save
3. **Force kill as last resort** - Only after timeout
4. **User notifications** - Always inform user of actions

## Performance Notes

- Timer interval: 1.5 seconds (balance between responsiveness and CPU usage)
- Checking ~100 apps takes <10ms
- Termination is async and non-blocking

## Known Limitations

- Apps can still launch briefly before being killed
- Very fast app launches might not be caught immediately
- Background processes without UI might restart

## Success Criteria

- Blocked apps terminate within 1-2 seconds
- No system instability
- Low CPU usage (<5% when monitoring)
- User receives notifications
- Can start/stop monitoring reliably

## Estimated Time

2-3 hours

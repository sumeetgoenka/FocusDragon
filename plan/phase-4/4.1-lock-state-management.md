# 4.1 Lock State Management

**Objective:** Create a robust lock system that prevents users from disabling blocks, with persistent state management.

## Overview

The lock system provides multiple lock types that prevent users from stopping blocks:
- Timer Lock: Count down to automatic unlock
- Random Text Lock: Require typing random string
- Schedule Lock: Lock during specific times
- Restart Lock: Survive system reboots

## Data Models

### Step 1: Create Lock Models

Create `Models/LockState.swift`:

```swift
import Foundation

enum LockType: String, Codable {
    case none = "none"
    case timer = "timer"
    case randomText = "random_text"
    case schedule = "schedule"
    case restart = "restart"

    var displayName: String {
        switch self {
        case .none: return "No Lock"
        case .timer: return "Timer Lock"
        case .randomText: return "Random Text Lock"
        case .schedule: return "Schedule Lock"
        case .restart: return "Restart Lock"
        }
    }
}

struct LockState: Codable, Equatable {
    var type: LockType
    var isLocked: Bool
    var createdAt: Date
    var unlockAt: Date?

    // Timer lock properties
    var timerDuration: TimeInterval?
    var remainingTime: TimeInterval?

    // Random text lock properties
    var randomText: String?
    var textAttempts: Int = 0
    var maxAttempts: Int = 5

    // Schedule lock properties
    var scheduleStart: Date?
    var scheduleEnd: Date?
    var scheduleDays: Set<Int>? // 1-7 for Monday-Sunday

    // Restart lock properties
    var restartLockCount: Int?
    var remainingRestarts: Int?

    init(type: LockType) {
        self.type = type
        self.isLocked = false
        self.createdAt = Date()
    }

    mutating func lock() {
        isLocked = true
        createdAt = Date()
    }

    mutating func unlock() {
        isLocked = false
        type = .none
        unlockAt = Date()
    }

    var canUnlock: Bool {
        guard isLocked else { return true }

        switch type {
        case .none:
            return true
        case .timer:
            return isTimerExpired
        case .randomText:
            return textAttempts < maxAttempts
        case .schedule:
            return !isInSchedule
        case .restart:
            return (remainingRestarts ?? 0) <= 0
        }
    }

    private var isTimerExpired: Bool {
        guard let unlockAt = unlockAt else { return false }
        return Date() >= unlockAt
    }

    private var isInSchedule: Bool {
        guard let start = scheduleStart,
              let end = scheduleEnd else {
            return false
        }

        let now = Date()
        let calendar = Calendar.current
        let currentWeekday = calendar.component(.weekday, from: now)

        // Check if today is in scheduled days
        if let days = scheduleDays, !days.contains(currentWeekday) {
            return false
        }

        return now >= start && now < end
    }
}

struct LockConfiguration: Codable {
    var allowedLockTypes: Set<LockType> = [.timer, .randomText, .schedule, .restart]
    var minTimerDuration: TimeInterval = 60 // 1 minute
    var maxTimerDuration: TimeInterval = 86400 // 24 hours
    var randomTextLength: Int = 8
    var maxTextAttempts: Int = 5

    static let `default` = LockConfiguration()
}
```

### Step 2: Create LockManager Service

Create `Services/LockManager.swift`:

```swift
import Foundation
import Combine

class LockManager: ObservableObject {
    static let shared = LockManager()

    @Published var currentLock: LockState = LockState(type: .none)
    @Published var configuration: LockConfiguration = .default

    private let userDefaults = UserDefaults.standard
    private let lockStateKey = "focusDragon.lockState"
    private let lockConfigKey = "focusDragon.lockConfig"

    private var updateTimer: Timer?
    private var cancellables = Set<AnyCancellable>()

    private init() {
        loadState()
        startUpdateTimer()

        // Auto-save on changes
        $currentLock
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .sink { [weak self] _ in
                self?.saveState()
            }
            .store(in: &cancellables)
    }

    // MARK: - Lock Creation

    func createTimerLock(duration: TimeInterval) throws {
        guard duration >= configuration.minTimerDuration,
              duration <= configuration.maxTimerDuration else {
            throw LockError.invalidDuration
        }

        var lock = LockState(type: .timer)
        lock.timerDuration = duration
        lock.remainingTime = duration
        lock.unlockAt = Date().addingTimeInterval(duration)
        lock.lock()

        currentLock = lock
        notifyDaemon()
    }

    func createRandomTextLock() {
        var lock = LockState(type: .randomText)
        lock.randomText = generateRandomText()
        lock.maxAttempts = configuration.maxTextAttempts
        lock.lock()

        currentLock = lock
        notifyDaemon()
    }

    func createScheduleLock(start: Date, end: Date, days: Set<Int>) throws {
        guard start < end else {
            throw LockError.invalidSchedule
        }

        var lock = LockState(type: .schedule)
        lock.scheduleStart = start
        lock.scheduleEnd = end
        lock.scheduleDays = days
        lock.lock()

        currentLock = lock
        notifyDaemon()
    }

    func createRestartLock(numberOfRestarts: Int) throws {
        guard numberOfRestarts > 0, numberOfRestarts <= 10 else {
            throw LockError.invalidRestartCount
        }

        var lock = LockState(type: .restart)
        lock.restartLockCount = numberOfRestarts
        lock.remainingRestarts = numberOfRestarts
        lock.lock()

        currentLock = lock
        notifyDaemon()
    }

    // MARK: - Lock Verification

    func attemptUnlock(with text: String? = nil) -> UnlockResult {
        guard currentLock.isLocked else {
            return .success
        }

        switch currentLock.type {
        case .none:
            currentLock.unlock()
            return .success

        case .timer:
            if currentLock.canUnlock {
                currentLock.unlock()
                return .success
            }
            return .failure(.timerNotExpired(remaining: currentLock.remainingTime ?? 0))

        case .randomText:
            guard let inputText = text else {
                return .failure(.textRequired)
            }

            if inputText == currentLock.randomText {
                currentLock.unlock()
                return .success
            } else {
                currentLock.textAttempts += 1
                saveState()

                if currentLock.textAttempts >= currentLock.maxAttempts {
                    return .failure(.maxAttemptsReached)
                }

                return .failure(.incorrectText(remaining: currentLock.maxAttempts - currentLock.textAttempts))
            }

        case .schedule:
            if currentLock.canUnlock {
                currentLock.unlock()
                return .success
            }
            return .failure(.scheduleLocked)

        case .restart:
            if currentLock.canUnlock {
                currentLock.unlock()
                return .success
            }
            return .failure(.restartsRemaining(count: currentLock.remainingRestarts ?? 0))
        }
    }

    func decrementRestartCounter() {
        guard currentLock.type == .restart,
              let remaining = currentLock.remainingRestarts,
              remaining > 0 else {
            return
        }

        currentLock.remainingRestarts = remaining - 1
        saveState()

        if currentLock.remainingRestarts == 0 {
            currentLock.unlock()
        }
    }

    // MARK: - Helpers

    private func generateRandomText() -> String {
        let characters = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"
        return String((0..<configuration.randomTextLength).map { _ in
            characters.randomElement()!
        })
    }

    private func startUpdateTimer() {
        updateTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateTimerLock()
        }
    }

    private func updateTimerLock() {
        guard currentLock.type == .timer,
              currentLock.isLocked,
              let unlockAt = currentLock.unlockAt else {
            return
        }

        let remaining = unlockAt.timeIntervalSinceNow
        currentLock.remainingTime = max(0, remaining)

        if remaining <= 0 {
            // Timer expired - auto unlock
            currentLock.unlock()
            notifyDaemon()
        }
    }

    private func notifyDaemon() {
        // Signal daemon about lock state change
        let notification = Notification.Name("FocusDragonLockStateChanged")
        NotificationCenter.default.post(name: notification, object: currentLock)
    }

    // MARK: - Persistence

    private func saveState() {
        if let encoded = try? JSONEncoder().encode(currentLock) {
            userDefaults.set(encoded, forKey: lockStateKey)
        }

        if let configEncoded = try? JSONEncoder().encode(configuration) {
            userDefaults.set(configEncoded, forKey: lockConfigKey)
        }
    }

    private func loadState() {
        if let data = userDefaults.data(forKey: lockStateKey),
           let decoded = try? JSONDecoder().decode(LockState.self, from: data) {
            currentLock = decoded
        }

        if let data = userDefaults.data(forKey: lockConfigKey),
           let decoded = try? JSONDecoder().decode(LockConfiguration.self, from: data) {
            configuration = decoded
        }
    }

    func reset() {
        currentLock = LockState(type: .none)
        saveState()
        notifyDaemon()
    }
}

// MARK: - Supporting Types

enum LockError: LocalizedError {
    case invalidDuration
    case invalidSchedule
    case invalidRestartCount
    case locked

    var errorDescription: String? {
        switch self {
        case .invalidDuration:
            return "Timer duration must be between 1 minute and 24 hours"
        case .invalidSchedule:
            return "Schedule end time must be after start time"
        case .invalidRestartCount:
            return "Restart count must be between 1 and 10"
        case .locked:
            return "Cannot modify while locked"
        }
    }
}

enum UnlockResult {
    case success
    case failure(UnlockFailure)

    var isSuccess: Bool {
        if case .success = self {
            return true
        }
        return false
    }
}

enum UnlockFailure {
    case timerNotExpired(remaining: TimeInterval)
    case textRequired
    case incorrectText(remaining: Int)
    case maxAttemptsReached
    case scheduleLocked
    case restartsRemaining(count: Int)

    var message: String {
        switch self {
        case .timerNotExpired(let time):
            let formatter = DateComponentsFormatter()
            formatter.allowedUnits = [.hour, .minute, .second]
            formatter.unitsStyle = .full
            return "Timer lock: \(formatter.string(from: time) ?? "") remaining"
        case .textRequired:
            return "Random text required to unlock"
        case .incorrectText(let remaining):
            return "Incorrect text. \(remaining) attempts remaining"
        case .maxAttemptsReached:
            return "Maximum attempts reached. Lock cannot be removed."
        case .scheduleLocked:
            return "Schedule lock is active"
        case .restartsRemaining(let count):
            return "\(count) restart(s) required before unlock"
        }
    }
}
```

### Step 3: Create Lock UI Components

Create `Views/LockSettingsView.swift`:

```swift
import SwiftUI

struct LockSettingsView: View {
    @ObservedObject var lockManager = LockManager.shared
    @State private var selectedLockType: LockType = .none
    @State private var timerHours: Int = 1
    @State private var timerMinutes: Int = 0
    @State private var showError: Bool = false
    @State private var errorMessage: String = ""

    var body: some View {
        VStack(spacing: 20) {
            Text("Add Lock Protection")
                .font(.headline)

            if lockManager.currentLock.isLocked {
                currentLockView
            } else {
                lockSelectionView
            }
        }
        .padding()
        .alert("Error", isPresented: $showError) {
            Button("OK", role: .cancel) {}
        } message: {
            Text(errorMessage)
        }
    }

    private var currentLockView: some View {
        VStack(spacing: 15) {
            HStack {
                Image(systemName: "lock.fill")
                    .foregroundColor(.red)
                Text("Block is Locked")
                    .font(.title3)
                    .fontWeight(.semibold)
            }

            Text(lockManager.currentLock.type.displayName)
                .font(.subheadline)
                .foregroundColor(.secondary)

            switch lockManager.currentLock.type {
            case .timer:
                timerLockStatus
            case .randomText:
                randomTextLockStatus
            case .schedule:
                scheduleLockStatus
            case .restart:
                restartLockStatus
            default:
                EmptyView()
            }

            Divider()

            unlockButton
        }
        .padding()
        .background(Color(.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var lockSelectionView: some View {
        VStack(spacing: 15) {
            Picker("Lock Type", selection: $selectedLockType) {
                Text("No Lock").tag(LockType.none)
                Text("Timer Lock").tag(LockType.timer)
                Text("Random Text Lock").tag(LockType.randomText)
                Text("Schedule Lock").tag(LockType.schedule)
                Text("Restart Lock").tag(LockType.restart)
            }
            .pickerStyle(.segmented)

            switch selectedLockType {
            case .timer:
                timerLockConfiguration
            case .randomText:
                randomTextLockConfiguration
            case .schedule:
                scheduleLockConfiguration
            case .restart:
                restartLockConfiguration
            default:
                Text("No lock protection")
                    .foregroundColor(.secondary)
            }

            if selectedLockType != .none {
                Button("Apply Lock") {
                    applyLock()
                }
                .buttonStyle(.borderedProminent)
            }
        }
    }

    // MARK: - Lock Configuration Views

    private var timerLockConfiguration: some View {
        VStack(spacing: 10) {
            Text("Block will unlock after:")
                .font(.subheadline)

            HStack {
                Stepper("Hours: \(timerHours)", value: $timerHours, in: 0...24)
                Stepper("Minutes: \(timerMinutes)", value: $timerMinutes, in: 0...59)
            }

            Text("Total: \(formatDuration())")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }

    private var randomTextLockConfiguration: some View {
        VStack(spacing: 10) {
            Text("You will need to type a random text to unlock")
                .font(.subheadline)
                .multilineTextAlignment(.center)

            Text("Maximum \(lockManager.configuration.maxTextAttempts) attempts")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }

    private var scheduleLockConfiguration: some View {
        Text("Schedule lock configuration")
            .font(.subheadline)
    }

    private var restartLockConfiguration: some View {
        Text("Restart lock configuration")
            .font(.subheadline)
    }

    // MARK: - Lock Status Views

    private var timerLockStatus: some View {
        VStack(spacing: 5) {
            if let remaining = lockManager.currentLock.remainingTime {
                Text("Time Remaining:")
                    .font(.caption)
                Text(formatTimeInterval(remaining))
                    .font(.title2)
                    .fontWeight(.bold)
                    .monospacedDigit()
            }
        }
    }

    private var randomTextLockStatus: some View {
        VStack(spacing: 5) {
            Text("Random Text Lock Active")
                .font(.caption)
            Text("Attempts: \(lockManager.currentLock.textAttempts)/\(lockManager.currentLock.maxAttempts)")
                .font(.subheadline)
        }
    }

    private var scheduleLockStatus: some View {
        Text("Schedule Lock Active")
            .font(.caption)
    }

    private var restartLockStatus: some View {
        VStack(spacing: 5) {
            Text("Restarts Required:")
                .font(.caption)
            Text("\(lockManager.currentLock.remainingRestarts ?? 0)")
                .font(.title2)
                .fontWeight(.bold)
        }
    }

    private var unlockButton: some View {
        Button("Attempt Unlock") {
            attemptUnlock()
        }
        .buttonStyle(.borderedProminent)
        .tint(.orange)
    }

    // MARK: - Actions

    private func applyLock() {
        do {
            switch selectedLockType {
            case .timer:
                let duration = TimeInterval(timerHours * 3600 + timerMinutes * 60)
                try lockManager.createTimerLock(duration: duration)
            case .randomText:
                lockManager.createRandomTextLock()
            case .schedule:
                // Implement schedule configuration
                break
            case .restart:
                // Implement restart configuration
                break
            default:
                break
            }
        } catch {
            showError = true
            errorMessage = error.localizedDescription
        }
    }

    private func attemptUnlock() {
        let result = lockManager.attemptUnlock()
        if case .failure(let failure) = result {
            showError = true
            errorMessage = failure.message
        }
    }

    // MARK: - Helpers

    private func formatDuration() -> String {
        let total = timerHours * 3600 + timerMinutes * 60
        return formatTimeInterval(TimeInterval(total))
    }

    private func formatTimeInterval(_ interval: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: interval) ?? ""
    }
}
```

## Testing Criteria

### Test 1: Timer Lock Creation
1. Select "Timer Lock"
2. Set duration to 2 hours
3. Apply lock
4. **Expected:** Lock state shows 2:00:00 remaining
5. **Expected:** Block cannot be stopped

### Test 2: Timer Lock Countdown
1. Create timer lock with 1 minute
2. Wait and observe countdown
3. **Expected:** Time decreases each second
4. **Expected:** Auto-unlocks at 0:00:00

### Test 3: Random Text Lock
1. Create random text lock
2. **Expected:** Random 8-character code displayed
3. Attempt unlock with wrong text
4. **Expected:** Attempt counter increases
5. Enter correct text
6. **Expected:** Unlocks successfully

### Test 4: Lock Persistence
1. Create timer lock
2. Quit application
3. Relaunch application
4. **Expected:** Lock still active with correct remaining time

### Test 5: Multiple Lock Types
1. Try switching between lock types
2. **Expected:** Can only have one active lock at a time

## Deliverables

✅ Lock state data models
✅ Lock manager service
✅ Lock UI components
✅ Persistence system
✅ Timer countdown logic
✅ Random text generation
✅ Unlock verification

## Security Considerations

1. **State persistence** - Lock state must survive app restarts
2. **Time validation** - Verify timer hasn't been tampered
3. **Attempt limiting** - Max attempts for random text
4. **Configuration validation** - Validate all inputs

## Performance Notes

- Lock state updates every 1 second for timer
- Minimal CPU usage (<0.1%)
- UserDefaults for persistence (fast access)

## Next Steps

Move to [4.2-timer-lock.md](./4.2-timer-lock.md) for detailed timer implementation.

## Estimated Time

**3-4 hours**

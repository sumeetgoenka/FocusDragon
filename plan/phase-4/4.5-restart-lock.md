# 4.5 Restart Lock Implementation

**Objective:** Implement lock that requires system restarts before allowing unlock, surviving reboots.

## Overview

Restart lock requires N system reboots before allowing block removal. Counter decrements on each restart and persists in daemon's protected storage.

## Implementation Steps

### Step 1: Boot Detection System

Create `Services/BootDetector.swift`:

```swift
import Foundation
import IOKit

class BootDetector {
    static let shared = BootDetector()

    private init() {}

    func getBootTime() -> Date? {
        var mib = [CTL_KERN, KERN_BOOTTIME]
        var bootTime = timeval()
        var size = MemoryLayout<timeval>.stride

        let result = sysctl(&mib, UInt32(mib.count), &bootTime, &size, nil, 0)

        guard result == 0 else {
            return nil
        }

        let timeInterval = Double(bootTime.tv_sec) + Double(bootTime.tv_usec) / 1_000_000.0
        return Date(timeIntervalSince1970: timeInterval)
    }

    func getUptime() -> TimeInterval? {
        guard let bootTime = getBootTime() else {
            return nil
        }

        return Date().timeIntervalSince(bootTime)
    }

    func didRebootSince(_ date: Date) -> Bool {
        guard let bootTime = getBootTime() else {
            return false
        }

        return bootTime > date
    }
}
```

### Step 2: Restart Lock State Manager

Create `Services/RestartLockManager.swift`:

```swift
import Foundation
import Combine

class RestartLockManager: ObservableObject {
    static let shared = RestartLockManager()

    @Published var isActive: Bool = false
    @Published var requiredRestarts: Int = 0
    @Published var remainingRestarts: Int = 0
    @Published var lastBootTime: Date?

    private let persistenceFile = "/Library/Application Support/FocusDragon/restart_lock.json"
    private var timer: Timer?

    struct State: Codable {
        let isActive: Bool
        let requiredRestarts: Int
        let remainingRestarts: Int
        let lastBootTime: Date
        let createdAt: Date
    }

    private init() {
        loadState()
        startMonitoring()
    }

    // MARK: - Activation

    func activate(requiredRestarts: Int) {
        guard requiredRestarts > 0, requiredRestarts <= 10 else {
            return
        }

        self.requiredRestarts = requiredRestarts
        self.remainingRestarts = requiredRestarts
        self.isActive = true
        self.lastBootTime = BootDetector.shared.getBootTime()

        saveState()
        NotificationHelper.shared.showRestartLockActivated(count: requiredRestarts)
    }

    func deactivate() {
        isActive = false
        requiredRestarts = 0
        remainingRestarts = 0
        lastBootTime = nil

        clearState()
        NotificationHelper.shared.showRestartLockDeactivated()
    }

    // MARK: - Monitoring

    private func startMonitoring() {
        // Check every 30 seconds for system restarts
        timer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in
            self?.checkForRestart()
        }

        // Check immediately
        checkForRestart()
    }

    private func checkForRestart() {
        guard isActive, let lastBoot = lastBootTime else {
            return
        }

        if BootDetector.shared.didRebootSince(lastBoot) {
            // System was restarted!
            handleRestart()
        }
    }

    private func handleRestart() {
        remainingRestarts = max(0, remainingRestarts - 1)
        lastBootTime = BootDetector.shared.getBootTime()

        saveState()

        if remainingRestarts == 0 {
            // All restarts completed - unlock
            NotificationHelper.shared.showRestartLockCompleted()
            deactivate()
        } else {
            NotificationHelper.shared.showRestartDetected(remaining: remainingRestarts)
        }
    }

    var canUnlock: Bool {
        return !isActive || remainingRestarts <= 0
    }

    // MARK: - Persistence

    private func saveState() {
        let state = State(
            isActive: isActive,
            requiredRestarts: requiredRestarts,
            remainingRestarts: remainingRestarts,
            lastBootTime: lastBootTime ?? Date(),
            createdAt: Date()
        )

        do {
            let data = try JSONEncoder().encode(state)

            // Create directory if needed
            let dir = (persistenceFile as NSString).deletingLastPathComponent
            try FileManager.default.createDirectory(
                atPath: dir,
                withIntermediateDirectories: true
            )

            try data.write(to: URL(fileURLWithPath: persistenceFile))
        } catch {
            print("RestartLockManager: Failed to save state: \(error)")
        }
    }

    private func loadState() {
        guard FileManager.default.fileExists(atPath: persistenceFile) else {
            return
        }

        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: persistenceFile))
            let state = try JSONDecoder().decode(State.self, from: data)

            isActive = state.isActive
            requiredRestarts = state.requiredRestarts
            remainingRestarts = state.remainingRestarts
            lastBootTime = state.lastBootTime
        } catch {
            print("RestartLockManager: Failed to load state: \(error)")
        }
    }

    private func clearState() {
        try? FileManager.default.removeItem(atPath: persistenceFile)
    }
}
```

### Step 3: Restart Lock UI

Create `Views/RestartLockView.swift`:

```swift
import SwiftUI

struct RestartLockView: View {
    @StateObject private var manager = RestartLockManager.shared
    @State private var selectedCount: Int = 3

    var body: some View {
        VStack(spacing: 20) {
            if manager.isActive {
                activeLockView
            } else {
                setupView
            }
        }
        .padding()
    }

    private var setupView: some View {
        VStack(spacing: 20) {
            Image(systemName: "arrow.clockwise.circle.fill")
                .font(.system(size: 60))
                .foregroundColor(.orange)

            Text("Restart Lock")
                .font(.title2)
                .fontWeight(.semibold)

            Text("Require system restarts before unlocking")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            VStack(alignment: .leading, spacing: 10) {
                Label("Ultimate commitment mechanism", systemImage: "checkmark.circle")
                Label("Survives app termination", systemImage: "checkmark.circle")
                Label("Enforced by daemon", systemImage: "checkmark.circle")
            }
            .font(.subheadline)
            .foregroundColor(.secondary)

            Divider()

            VStack(spacing: 15) {
                Text("Number of Restarts Required")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                Picker("Restarts", selection: $selectedCount) {
                    ForEach(1...10, id: \.self) { count in
                        Text("\(count)").tag(count)
                    }
                }
                .pickerStyle(.segmented)

                Text(warningText)
                    .font(.caption)
                    .foregroundColor(.orange)
                    .multilineTextAlignment(.center)
                    .padding()
                    .background(Color.orange.opacity(0.1))
                    .cornerRadius(8)
            }

            Button("Activate Restart Lock") {
                manager.activate(requiredRestarts: selectedCount)
            }
            .buttonStyle(.borderedProminent)
            .tint(.orange)
        }
    }

    private var activeLockView: some View {
        VStack(spacing: 25) {
            ZStack {
                Circle()
                    .fill(Color.orange.opacity(0.1))
                    .frame(width: 120, height: 120)

                VStack {
                    Image(systemName: "arrow.clockwise")
                        .font(.system(size: 40))
                        .foregroundColor(.orange)

                    Text("\(manager.remainingRestarts)")
                        .font(.system(size: 32, weight: .bold))
                        .foregroundColor(.orange)
                }
            }

            Text("Restart Lock Active")
                .font(.title3)
                .fontWeight(.semibold)

            VStack(spacing: 10) {
                Text("Restarts Remaining:")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                HStack(spacing: 10) {
                    ForEach(0..<manager.requiredRestarts, id: \.self) { index in
                        Circle()
                            .fill(index < (manager.requiredRestarts - manager.remainingRestarts) ?
                                  Color.green : Color.gray.opacity(0.3))
                            .frame(width: 20, height: 20)
                            .overlay(
                                Image(systemName: index < (manager.requiredRestarts - manager.remainingRestarts) ?
                                      "checkmark" : "arrow.clockwise")
                                    .font(.system(size: 10))
                                    .foregroundColor(.white)
                            )
                    }
                }
            }

            VStack(spacing: 5) {
                Text("Instructions:")
                    .font(.headline)

                Text("Restart your system \(manager.remainingRestarts) more time(s) to unlock")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }
            .padding()
            .background(Color(.controlBackgroundColor))
            .cornerRadius(8)

            if let uptime = BootDetector.shared.getUptime() {
                Text("System uptime: \(formatUptime(uptime))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            restartInstructions
        }
    }

    private var restartInstructions: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("How to Restart:")
                .font(.headline)

            VStack(alignment: .leading, spacing: 5) {
                Label("Apple menu → Restart", systemImage: "1.circle.fill")
                Label("Click 'Restart' to confirm", systemImage: "2.circle.fill")
                Label("Wait for system to boot", systemImage: "3.circle.fill")
                Label("Counter will decrement", systemImage: "4.circle.fill")
            }
            .font(.caption)
            .foregroundColor(.secondary)
        }
        .padding()
        .background(Color(.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var warningText: String {
        if selectedCount == 1 {
            return "Requires 1 system restart to unlock"
        } else {
            return "Requires \(selectedCount) system restarts to unlock. This is a strong commitment!"
        }
    }

    private func formatUptime(_ interval: TimeInterval) -> String {
        let hours = Int(interval) / 3600
        let minutes = (Int(interval) % 3600) / 60

        if hours > 24 {
            let days = hours / 24
            return "\(days) day(s), \(hours % 24) hour(s)"
        } else {
            return "\(hours) hour(s), \(minutes) minute(s)"
        }
    }
}
```

### Step 4: Daemon Integration

Update `DaemonService.swift`:

```swift
class DaemonService {
    private var restartLockManager: RestartLockManager?

    func start() {
        // Initialize restart lock manager
        restartLockManager = RestartLockManager.shared

        // Check if restart lock is active
        if restartLockManager?.isActive == true {
            log("Restart lock active: \(restartLockManager?.remainingRestarts ?? 0) restarts remaining")

            // Force blocking if restart lock active
            enforceRestartLock()
        }

        // ... rest of daemon startup
    }

    private func enforceRestartLock() {
        // Ensure blocking remains active
        if currentConfig?.isBlocking == false {
            currentConfig?.isBlocking = true
            saveConfig()
            applyBlocking()
        }
    }

    private func handleUnlockRequest() -> Bool {
        // Check restart lock
        if restartLockManager?.isActive == true,
           restartLockManager?.canUnlock == false {
            log("Unlock denied: Restart lock active")
            return false
        }

        // ... rest of unlock logic
        return true
    }
}
```

## Testing Criteria

### Test 1: Lock Activation
1. Select 3 restarts
2. Click "Activate Restart Lock"
3. **Expected:** Shows "3 restarts remaining"
4. **Expected:** Cannot stop blocking

### Test 2: Restart Detection
1. Activate lock with 3 restarts
2. Restart system
3. **Expected:** Counter shows 2 restarts remaining
4. **Expected:** Notification shown

### Test 3: Multiple Restarts
1. Activate with 3 restarts
2. Restart 3 times
3. **Expected:** After 3rd restart, lock removed
4. **Expected:** Can now stop blocking

### Test 4: Persistence
1. Activate lock
2. Force quit app and daemon
3. Restart system
4. **Expected:** Counter decrements correctly
5. **Expected:** Lock still enforced

### Test 5: Boot Time Detection
1. Check system uptime display
2. **Expected:** Shows accurate uptime
3. Restart system
4. **Expected:** Uptime resets to ~0

### Test 6: Cannot Bypass
1. Activate restart lock
2. Try to stop blocking via UI
3. **Expected:** Blocked
4. Try to kill daemon
5. **Expected:** Daemon restarts, lock persists

## Deliverables

✅ Boot detection system
✅ Restart lock manager
✅ Restart counter UI
✅ Visual progress indicators
✅ Daemon integration
✅ Persistent state storage
✅ Restart instructions
✅ Notifications

## Security Considerations

1. **Protected storage** - State file in daemon directory
2. **Boot time verification** - Uses system APIs
3. **Cannot reset** - File protected by daemon
4. **Survives termination** - Daemon enforces

## Performance Notes

- Check interval: 30 seconds
- Boot time query: <1ms
- Minimal CPU/memory usage

## Known Limitations

- Requires actual system restart (not sleep/wake)
- Counter protected but file could be manually deleted
- Maximum 10 restarts

## Success Criteria

- Detects system restarts accurately
- Counter decrements correctly
- Survives app/daemon termination
- Cannot be bypassed
- Auto-unlocks after required restarts

## Estimated Time

**2-3 hours**

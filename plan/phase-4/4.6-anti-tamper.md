# 4.6 Anti-Tamper Protection

**Objective:** Prevent users from circumventing blocks through System Settings, Terminal, Activity Monitor, etc.

## Overview

Anti-tamper mechanisms detect and block attempts to disable FocusDragon through system tools, developer tools, and configuration changes.

## Implementation Steps

### Step 1: System Settings Blocker

Create `Services/SystemSettingsBlocker.swift`:

```swift
import Foundation
import AppKit

class SystemSettingsBlocker {
    static let shared = SystemSettingsBlocker()

    private let blockedSettings: Set<String> = [
        "com.apple.systempreferences", // System Settings
        "com.apple.preference.network", // Network settings
        "com.apple.preference.datetime", // Date & Time
        "com.apple.preference.security" // Security & Privacy
    ]

    private var isMonitoring = false
    private var timer: Timer?

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true

        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.checkForBlockedApps()
        }
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
    }

    private func checkForBlockedApps() {
        let runningApps = NSWorkspace.shared.runningApplications

        for app in runningApps {
            guard let bundleId = app.bundleIdentifier else { continue }

            if blockedSettings.contains(bundleId) {
                terminateApp(app, name: app.localizedName ?? bundleId)
            }
        }
    }

    private func terminateApp(_ app: NSRunningApplication, name: String) {
        print("SystemSettingsBlocker: Terminating \(name)")

        // Force terminate
        _ = app.forceTerminate()

        // Also kill via PID for good measure
        let pid = app.processIdentifier
        kill(pid, SIGKILL)

        NotificationHelper.shared.showSystemSettingsBlocked(appName: name)
    }
}
```

### Step 2: Terminal Blocker

Create `Services/TerminalBlocker.swift`:

```swift
import Foundation
import AppKit

class TerminalBlocker {
    static let shared = TerminalBlocker()

    private let blockedTerminals: Set<String> = [
        "com.apple.Terminal",
        "com.googlecode.iterm2",
        "com.microsoft.VSCode", // VSCode integrated terminal
        "com.sublimetext.4",
        "com.jetbrains.intellij"
    ]

    private let blockedCommands: Set<String> = [
        "launchctl", // Control daemons
        "sudo",      // Root access
        "pkill",     // Kill processes
        "killall",   // Kill by name
        "defaults"   // Modify preferences
    ]

    private var isMonitoring = false
    private var timer: Timer?

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true

        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            self?.checkForTerminals()
        }
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
    }

    private func checkForTerminals() {
        let runningApps = NSWorkspace.shared.runningApplications

        for app in runningApps {
            guard let bundleId = app.bundleIdentifier else { continue }

            if blockedTerminals.contains(bundleId) {
                terminateTerminal(app)
            }
        }
    }

    private func terminateTerminal(_ app: NSRunningApplication) {
        let name = app.localizedName ?? "Terminal"
        print("TerminalBlocker: Terminating \(name)")

        _ = app.forceTerminate()

        let pid = app.processIdentifier
        kill(pid, SIGKILL)

        NotificationHelper.shared.showTerminalBlocked()
    }

    func isCommandAllowed(_ command: String) -> Bool {
        let commandName = (command as NSString).lastPathComponent

        for blocked in blockedCommands {
            if commandName.contains(blocked) {
                return false
            }
        }

        return true
    }
}
```

### Step 3: Activity Monitor Blocker

Create `Services/ActivityMonitorBlocker.swift`:

```swift
import Foundation
import AppKit

class ActivityMonitorBlocker {
    static let shared = ActivityMonitorBlocker()

    private let activityMonitorBundleId = "com.apple.ActivityMonitor"
    private var isMonitoring = false
    private var timer: Timer?

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true

        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            self?.checkForActivityMonitor()
        }
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
    }

    private func checkForActivityMonitor() {
        let runningApps = NSWorkspace.shared.runningApplications

        for app in runningApps {
            guard let bundleId = app.bundleIdentifier else { continue }

            if bundleId == activityMonitorBundleId {
                terminateActivityMonitor(app)
            }
        }
    }

    private func terminateActivityMonitor(_ app: NSRunningApplication) {
        print("ActivityMonitorBlocker: Terminating Activity Monitor")

        _ = app.forceTerminate()

        let pid = app.processIdentifier
        kill(pid, SIGKILL)

        NotificationHelper.shared.showActivityMonitorBlocked()
    }
}
```

### Step 4: File System Monitor

Create `Services/FileSystemMonitor.swift`:

```swift
import Foundation

class FileSystemMonitor {
    static let shared = FileSystemMonitor()

    private let protectedPaths: [String] = [
        "/Library/LaunchDaemons/com.focusdragon.daemon.plist",
        "/Library/Application Support/FocusDragon/",
        "/etc/hosts"
    ]

    private var fileDescriptors: [Int32] = []
    private var dispatchSources: [DispatchSourceFileSystemObject] = []

    func startMonitoring() {
        for path in protectedPaths {
            monitorPath(path)
        }
    }

    func stopMonitoring() {
        for source in dispatchSources {
            source.cancel()
        }

        for fd in fileDescriptors {
            close(fd)
        }

        dispatchSources.removeAll()
        fileDescriptors.removeAll()
    }

    private func monitorPath(_ path: String) {
        let fd = open(path, O_EVTONLY)
        guard fd >= 0 else {
            print("FileSystemMonitor: Failed to open \(path)")
            return
        }

        fileDescriptors.append(fd)

        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fd,
            eventMask: [.write, .delete, .rename],
            queue: DispatchQueue.global()
        )

        source.setEventHandler { [weak self] in
            self?.handleFileSystemEvent(path: path)
        }

        source.resume()
        dispatchSources.append(source)
    }

    private func handleFileSystemEvent(path: String) {
        print("FileSystemMonitor: Detected modification to \(path)")

        // Take corrective action
        if path.contains("daemon.plist") {
            restoreDaemonPlist()
        } else if path.contains("FocusDragon") {
            restoreConfigFiles()
        } else if path.contains("hosts") {
            restoreHostsFile()
        }

        NotificationHelper.shared.showTamperDetected(path: path)
    }

    private func restoreDaemonPlist() {
        // Daemon will restore itself on next check
        print("FileSystemMonitor: Daemon plist modified, will restore")
    }

    private func restoreConfigFiles() {
        print("FileSystemMonitor: Config files modified, will restore")
    }

    private func restoreHostsFile() {
        // HostsWatcher handles this
        print("FileSystemMonitor: Hosts file modified, will restore")
    }
}
```

### Step 5: Process Protection

Create `Services/ProcessProtection.swift`:

```swift
import Foundation

class ProcessProtection {
    static let shared = ProcessProtection()

    private let protectedProcesses: Set<String> = [
        "FocusDragonDaemon",
        "focusdragon_daemon"
    ]

    private var timer: Timer?

    func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
            self?.checkProtectedProcesses()
        }

        // Check immediately
        checkProtectedProcesses()
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
    }

    private func checkProtectedProcesses() {
        // Check if daemon is running
        let isDaemonRunning = checkProcess("FocusDragonDaemon")

        if !isDaemonRunning {
            print("ProcessProtection: Daemon not running, attempting restart")
            restartDaemon()
        }
    }

    private func checkProcess(_ name: String) -> Bool {
        let task = Process()
        task.launchPath = "/bin/ps"
        task.arguments = ["-ax"]

        let pipe = Pipe()
        task.standardOutput = pipe

        try? task.run()
        task.waitUntilExit()

        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: data, encoding: .utf8) ?? ""

        return output.contains(name)
    }

    private func restartDaemon() {
        let task = Process()
        task.launchPath = "/bin/launchctl"
        task.arguments = ["start", "com.focusdragon.daemon"]

        try? task.run()

        NotificationHelper.shared.showDaemonRestarted()
    }
}
```

### Step 6: Tamper Detection Coordinator

Create `Services/TamperDetection.swift`:

```swift
import Foundation
import Combine

class TamperDetection: ObservableObject {
    static let shared = TamperDetection()

    @Published var isMonitoring = false
    @Published var tamperAttempts: Int = 0
    @Published var lastTamperDate: Date?

    private var cancellables = Set<AnyCancellable>()

    private init() {}

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true

        SystemSettingsBlocker.shared.startMonitoring()
        TerminalBlocker.shared.startMonitoring()
        ActivityMonitorBlocker.shared.startMonitoring()
        FileSystemMonitor.shared.startMonitoring()
        ProcessProtection.shared.startMonitoring()

        print("TamperDetection: All monitors started")
    }

    func stopMonitoring() {
        isMonitoring = false

        SystemSettingsBlocker.shared.stopMonitoring()
        TerminalBlocker.shared.stopMonitoring()
        ActivityMonitorBlocker.shared.stopMonitoring()
        FileSystemMonitor.shared.stopMonitoring()
        ProcessProtection.shared.stopMonitoring()

        print("TamperDetection: All monitors stopped")
    }

    func recordTamperAttempt() {
        tamperAttempts += 1
        lastTamperDate = Date()

        saveStats()
    }

    private let statsKey = "tamperDetectionStats"

    private func saveStats() {
        let stats: [String: Any] = [
            "attempts": tamperAttempts,
            "lastDate": lastTamperDate?.timeIntervalSince1970 ?? 0
        ]

        UserDefaults.standard.set(stats, forKey: statsKey)
    }

    func loadStats() {
        guard let stats = UserDefaults.standard.dictionary(forKey: statsKey) else {
            return
        }

        tamperAttempts = stats["attempts"] as? Int ?? 0

        if let timestamp = stats["lastDate"] as? TimeInterval {
            lastTamperDate = Date(timeIntervalSince1970: timestamp)
        }
    }
}
```

### Step 7: Add Notifications

Extend `NotificationHelper.swift`:

```swift
extension NotificationHelper {
    func showSystemSettingsBlocked(appName: String) {
        let content = UNMutableNotificationContent()
        content.title = "System Settings Blocked"
        content.body = "\(appName) was blocked to prevent tampering"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }

    func showTerminalBlocked() {
        let content = UNMutableNotificationContent()
        content.title = "Terminal Blocked"
        content.body = "Terminal access blocked during focus session"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }

    func showActivityMonitorBlocked() {
        let content = UNMutableNotificationContent()
        content.title = "Activity Monitor Blocked"
        content.body = "Cannot view processes during focus session"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }

    func showTamperDetected(path: String) {
        let content = UNMutableNotificationContent()
        content.title = "Tamper Detected"
        content.body = "Detected modification to \(path)"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)

        TamperDetection.shared.recordTamperAttempt()
    }

    func showDaemonRestarted() {
        let content = UNMutableNotificationContent()
        content.title = "FocusDragon Protected"
        content.body = "Daemon was restarted automatically"
        content.sound = .default

        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request)
    }
}
```

## Testing Criteria

### Test 1: System Settings Blocking
1. Start blocking with tamper protection
2. Try to open System Settings
3. **Expected:** System Settings killed immediately
4. **Expected:** Notification shown

### Test 2: Terminal Blocking
1. Start blocking
2. Try to open Terminal
3. **Expected:** Terminal killed within 1 second
4. Try to open iTerm2
5. **Expected:** Also killed

### Test 3: Activity Monitor Blocking
1. Start blocking
2. Try to open Activity Monitor
3. **Expected:** Killed immediately
4. **Expected:** Cannot view processes

### Test 4: File System Protection
1. Start blocking
2. Try to modify daemon plist
3. **Expected:** File restored automatically
4. **Expected:** Tamper notification

### Test 5: Process Protection
1. Start blocking
2. Force kill daemon process
3. Wait 5 seconds
4. **Expected:** Daemon automatically restarts
5. **Expected:** Blocking still enforced

### Test 6: Hosts File Protection
1. Start blocking
2. Edit /etc/hosts to remove FocusDragon block
3. Wait 5 seconds
4. **Expected:** Block section restored
5. **Expected:** Sites still blocked

### Test 7: Multiple Tamper Attempts
1. Try various bypass methods
2. Check tamper attempts counter
3. **Expected:** Each attempt recorded
4. **Expected:** Statistics saved

## Deliverables

✅ System Settings blocker
✅ Terminal blocker
✅ Activity Monitor blocker
✅ File system monitor
✅ Process protection
✅ Tamper detection coordinator
✅ Tamper statistics tracking
✅ Comprehensive notifications

## Security Considerations

1. **Defense in depth** - Multiple protection layers
2. **Auto-recovery** - Automatic restoration
3. **Monitoring frequency** - Balance security vs performance
4. **Protected processes** - Daemon self-protection
5. **File protection** - Monitor critical files

## Performance Notes

- System Settings check: 1s interval
- Terminal check: 0.5s interval
- Activity Monitor check: 0.5s interval
- Process check: 5s interval
- File system: Event-driven
- Combined CPU: <2%

## Known Limitations

- Advanced users can still bypass with root shell
- Cannot block console access (Command+Shift+G to /etc/hosts)
- Kernel extensions could interfere
- Safe mode boots bypass protections

## Success Criteria

- System Settings blocked reliably
- Terminal apps killed quickly
- Activity Monitor blocked
- File modifications detected and restored
- Daemon self-restarts on kill
- Minimal performance impact
- User receives clear notifications

## Estimated Time

**4-5 hours**
